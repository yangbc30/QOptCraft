{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"QOptCraft","text":"<p>A Python package for the design and study of linear optical quantum systems.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Documentation and examples can be found here.</p>"},{"location":"#installation","title":"Installation","text":"<p>Create and activate a new conda environment <pre><code>conda create --name test python==3.11\nconda activate test\n</code></pre> Clone the repository <pre><code>git clone -b optimized https://github.tel.uva.es/juagar/qoptcraft.git\n</code></pre></p> <p>Install with <code>pip</code>: <pre><code>pip install git+https://github.tel.uva.es/juagar/qoptcraft.git@optimized\n</code></pre></p>"},{"location":"#quick-usage","title":"Quick usage","text":""},{"location":"#clemens-and-reck-decompositions","title":"Clemens and Reck decompositions","text":"<p>We can decompose any unitary into beamsplitters and phase shifters: <pre><code>from qoptcraft.optical_elements import clemens_decomposition, reck_decomposition\nfrom qoptcraft.operators import haar_random_unitary\n\nmodes = 4\nunitary = haar_random_unitary(modes)\nleft, diag, right = clemens_decomposition(unitary)\ndiag, right = reck_decomposition(unitary)\n</code></pre></p>"},{"location":"#basis","title":"Basis","text":"<p>We can get easily get the basis of the unitary algebra <pre><code>from qoptcraft.basis import get_algebra_basis\n\nmodes = 2\nphotons = 3\nbasis_algebra, basis_image_algebra = get_algebra_basis(modes, photons)\n</code></pre></p> <p>or the Fock state basis of the Hilbert space <pre><code>from qoptcraft.basis import get_photon_basis, hilbert_dim\n\nphoton_basis = get_photon_basis(modes, photons)\ndimension = hilbert_dim(modes, photons)  # should equal len(photon_basis)\n</code></pre></p>"},{"location":"#states","title":"States","text":"<p>We can create pure quantum states by summing Fock states: <pre><code>from math import sqrt\n\nfrom qoptcraft.state import Fock\n\nin_fock = Fock(1, 1, 0, 0)\nbell_state = 1 / sqrt(2) * Fock(1, 0, 1, 0) + 1 / sqrt(2) * Fock(0, 1, 0, 1)\n</code></pre></p>"},{"location":"#invariants","title":"Invariants","text":"<p>To check if transitions between quantum states are forbidden by a linear optical transformation, we simply run <pre><code>from qoptcraft.invariant import forbidden_transition, photon_invariant\n\nforbidden_transition(in_fock, bell_state, method=\"reduced\")\n</code></pre> <pre><code>&gt;&gt;&gt; True\n</code></pre></p> <p>The invariant can be calculated from density matrices (calculations use the basis of the algebra) To check if transitions between quantum states are forbidden by a linear optical transformation, we simply run <pre><code>from qoptcraft.state import MixedState\nfrom qoptcraft.invariant import forbidden_transition, photon_invariant\n\nmixed_state = MixedState.from_mixture(pure_states=[in_fock, bell_state], probs=[0.5, 0.5])\nforbidden_transition(mixed_state, bell_state, method=\"basis\")\n</code></pre> <pre><code>&gt;&gt;&gt; True\n</code></pre></p>"},{"location":"#quantizing-linear-interferomenters","title":"Quantizing linear interferomenters","text":"<p>We can easily compute the unitary matrix associated with a linear interferometer S and a certain number of photons. There are four different methods to compute the unitary: <code>'heisenberg'</code>, <code>'hamiltonian'</code>, <code>'permanent glynn'</code> and <code>'permanent ryser'</code>.</p> <pre><code>from qoptcraft.operators import haar_random_unitary\nfrom qoptcraft.evolution import photon_unitary\n\nmodes = 2\nphotons = 3\ninterferometer = haar_random_unitary(modes)\nunitary_heisenberg = photon_unitary(interferometer, photons, method=\"heisenberg\")\nunitary_hamiltonian = photon_unitary(interferometer, photons, method=\"hamiltonian\")\nunitary_glynn = photon_unitary(interferometer, photons, method=\"permanent glynn\")\nunitary_ryser = photon_unitary(interferometer, photons, method=\"permanent ryser\")\n</code></pre> <p>We can apply this function to a 50:50 beamsplitter to recover the Hong-Ou-Mandel matrix</p> <pre><code>from numpy import pi as PI\nfrom qoptcraft.optical_elements import beam_splitter\n\nbs_matrix = beam_splitter(angle=PI/4, shift=0, dim=2, mode_1=0, mode_2=1, convention=\"clemens\")\nhong_ou_mandel = photon_unitary(bs_matrix, photons=3, method=\"heisenberg\")\n</code></pre>"},{"location":"#retrieve-the-linear-optical-scattering-matrix-from-the-quantized-unitary","title":"Retrieve the linear optical scattering matrix from the quantized unitary","text":"<p>If a given unitary matrix comes from a linear optical scattering matrix, we can retrieve it <pre><code>from qoptcraft import haar_random_unitary, photon_unitary, scattering_from_unitary\n\nmodes = 3\nphotons = 2\nS = haar_random_unitary(modes)\nU = photon_unitary(S, photons)\nS_rebuilt = scattering_from_unitary(U, modes, photons)\n</code></pre> If this scattering matrix doesn't exist, it will raise an <code>InconsistentEquations</code> error.</p>"},{"location":"#approximating-a-unitary-with-linear-optics-topogonov","title":"Approximating a unitary with linear optics (Topogonov)","text":"<pre><code>from qoptcraft.operators import qft\nfrom qoptcraft.topogonov import topogonov\n\nmodes = 3\nphotons = 2\nunitary = qft(6)\napprox_unitary, error = topogonov(unitary, modes, photons)\n</code></pre>"},{"location":"#citing","title":"Citing","text":"<p>QOptCraft is the work of Daniel G\u00f3mez Aguado (gomezaguado99@gmail.com) and Pablo V. Parellada (pablo.veganzones@uva.es). </p> <p>If you are doing research using qoptcraft, please cite our paper:</p> <pre><code>Daniel G\u00f3mez Aguado et al. qoptcraft: A Python package for the design and study of linear optical quantum systems. 2023. https://doi.org/10.1016/j.cpc.2022.108511\n</code></pre>"},{"location":"#references","title":"References","text":"<p>[1] W. R. Clements, P. C. Humphreys, B. J. Metcalf, W. S. Kolthammer, and I. A. Walsmley, \u201dOptimal Design for Universal Multiport Interferometers\u201d, Optica 3, 1460 (2016).</p> <p>[2] J. Skaar, J. C. Garc\u00eda Escart\u00edn, and H. Landro, \u201dQuantum mechanical description of linear optic\u201d, American Journal of Physics 72, 1385 (2004).</p> <p>[3] S. Scheel, \u201dPermanents in linear optics network\u201d, Acta Physica Slovaca 58, 675 (2008).</p> <p>[4] \u201dPermanents and Ryser\u2019s algorithm\u201d, numbersandshapes.net.</p> <p>[5] J. C. Garc\u00eda Escart\u00edn, V. Gimeno, and J. J. Moyano-Fern\u00e1ndez, \u201dMultiple photon effective Hamiltonians in linear quantum optical networks\u201d, Optics Communications 430 (2019) 434\u2013439.</p> <p>[6] J. C. Garc\u00eda Escart\u00edn, V. Gimeno, and J. J. Moyano Fern\u00e1ndez, \u201dA method to determine which quantum operations can be realized with linear optics with a constructive implementation recipe\u201d, Physical Review A 100, 022301 (2019).</p> <p>[7] J. C. Garc\u00eda Escart\u00edn and J. J. Moyano Fern\u00e1ndez, \u201dOptimal approximation to unitary quantum operators with linear optics\u201d, arXiv:2011.15048v1 [quant-ph].</p> <p>[8] N. Tischler, C. Rockstuhl, and K. Slowik, \u201dQuantum Optical Realization of Arbitrary Linear Transformations Allowing for Loss and Gain\u201d, Physical Review X 8, 021017 (2018).</p> <p>[9] T. A. Loring, \u201dComputing a logarithm of a unitary matrix with general spectrum\u201d, Numerical Linear Algebra wth Applications, 21 (6) 744\u2013760 (2014).</p>"},{"location":"#contributing","title":"Contributing","text":"<p>We appreciate and welcome contributions. For major changes, please open an issue first to discuss what you would like to change. Also, make sure to update tests as appropriate.</p> <p>If you are new to contributing to open source, this guide helps explain why, what, and how to get involved.</p>"},{"location":"#license","title":"License","text":"<p>This software is under the Apache License 2.0.</p>"},{"location":"examples/article/","title":"Article examples","text":"<p>In this short notebook, we perform the calculations used in the article No-go theorems for photon state transformations in quantum linear optics using the library <code>QOptCraft</code>.</p> In\u00a0[1]: Copied! <pre>import numpy as np\n\nfrom qoptcraft import (\n    Fock,\n    photon_invariant,\n    forbidden_transition,\n    get_algebra_basis,\n    get_photon_basis,\n)\nfrom qoptcraft.math import gram_schmidt\n</pre> import numpy as np  from qoptcraft import (     Fock,     photon_invariant,     forbidden_transition,     get_algebra_basis,     get_photon_basis, ) from qoptcraft.math import gram_schmidt <p>We begin by obtaining the basis of the Hilbert space with 2 modes and 2 photons:</p> In\u00a0[2]: Copied! <pre>modes = 2\nphotons = 2\nget_photon_basis(modes, photons)\n</pre> modes = 2 photons = 2 get_photon_basis(modes, photons) Out[2]: <pre>[(2, 0), (1, 1), (0, 2)]</pre> <p><code>QOptCraft</code> returns the basis of the image algebra as sparse matrices to save space. The following cell returns a basis of the image of the Lie algebra of hermitian matrices of dimension 2 under the photonic homomorphism for 2 photons.</p> In\u00a0[3]: Copied! <pre>basis_algebra, basis_image_algebra = get_algebra_basis(modes, photons)\nfor i, matrix in enumerate(basis_image_algebra):\n    print(f\"b{i + 1} = {matrix.toarray()}\\n\")\n</pre> basis_algebra, basis_image_algebra = get_algebra_basis(modes, photons) for i, matrix in enumerate(basis_image_algebra):     print(f\"b{i + 1} = {matrix.toarray()}\\n\") <pre>b1 = [[0.+2.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+1.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+0.j]]\n\nb2 = [[0.+0.j         0.+0.70710678j 0.+0.j        ]\n [0.+0.70710678j 0.+0.j         0.+0.70710678j]\n [0.+0.j         0.+0.70710678j 0.+0.j        ]]\n\nb3 = [[0.+0.j 0.+0.j 0.+0.j]\n [0.+0.j 0.+1.j 0.+0.j]\n [0.+0.j 0.+0.j 0.+2.j]]\n\nb4 = [[ 0.        +0.j -0.70710678+0.j  0.        +0.j]\n [ 0.70710678+0.j  0.        +0.j -0.70710678+0.j]\n [ 0.        +0.j  0.70710678+0.j  0.        +0.j]]\n\n</pre> <p>We can obtain an orthonormal basis using the gram-schmidt algorithm</p> In\u00a0[4]: Copied! <pre>ortho_basis_image = gram_schmidt(basis_image_algebra)\nfor i, matrix in enumerate(ortho_basis_image):\n    print(f\"c{i + 1} = {matrix.toarray()}\\n\")\n</pre> ortho_basis_image = gram_schmidt(basis_image_algebra) for i, matrix in enumerate(ortho_basis_image):     print(f\"c{i + 1} = {matrix.toarray()}\\n\") <pre>c1 = [[0.+0.89442719j 0.+0.j         0.+0.j        ]\n [0.+0.j         0.+0.4472136j  0.+0.j        ]\n [0.+0.j         0.+0.j         0.+0.j        ]]\n\nc2 = [[0.+0.j  0.+0.5j 0.+0.j ]\n [0.+0.5j 0.+0.j  0.+0.5j]\n [0.+0.j  0.+0.5j 0.+0.j ]]\n\nc3 = [[0.-0.18257419j 0.+0.j         0.+0.j        ]\n [0.+0.j         0.+0.36514837j 0.+0.j        ]\n [0.+0.j         0.+0.j         0.+0.91287093j]]\n\nc4 = [[ 0. +0.j -0.5+0.j  0. +0.j]\n [ 0.5+0.j  0. +0.j -0.5+0.j]\n [ 0. +0.j  0.5+0.j  0. +0.j]]\n\n</pre> <p>The function <code>photon_invariant</code> computes the tangent and perpendicular invariants (in this order).</p> In\u00a0[5]: Copied! <pre>state = Fock(2, 0)\nprint(f\"tangent_invariant = {photon_invariant(state)}\")\n</pre> state = Fock(2, 0) print(f\"tangent_invariant = {photon_invariant(state)}\") <pre>tangent_invariant = 0.8333333333333333\n</pre> In\u00a0[6]: Copied! <pre>state = Fock(1, 1)\nprint(f\"tangent_invariant = {photon_invariant(state)}\")\n</pre> state = Fock(1, 1) print(f\"tangent_invariant = {photon_invariant(state)}\") <pre>tangent_invariant = 0.3333333333333332\n</pre> In\u00a0[7]: Copied! <pre>state = Fock(0, 2)\nprint(f\"tangent_invariant = {photon_invariant(state)}\")\n</pre> state = Fock(0, 2) print(f\"tangent_invariant = {photon_invariant(state)}\") <pre>tangent_invariant = 0.8333333333333336\n</pre> <p>We also compute the invariant of the a 50:50 beamsplitter (Hong-Ou-Mandel experiment output)</p> In\u00a0[8]: Copied! <pre>state = (Fock(2, 0) - Fock(0, 2)) / np.sqrt(2)\nprint(f\"tangent_invariant = {photon_invariant(state)}\")\n</pre> state = (Fock(2, 0) - Fock(0, 2)) / np.sqrt(2) print(f\"tangent_invariant = {photon_invariant(state)}\") <pre>tangent_invariant = 0.3333333333333336\n</pre> In\u00a0[9]: Copied! <pre>state_in = Fock(1, 1)\nstate_out = Fock(2, 0) + Fock(0, 2)\nprint(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out)}\")\n</pre> state_in = Fock(1, 1) state_out = Fock(2, 0) + Fock(0, 2) print(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out)}\") <pre>In invariant = 0.3333333 \t Out invariant = 0.3333333\n\nForbidden transition? False\n</pre> In\u00a0[10]: Copied! <pre>state_in = Fock(2, 2)\nstate_out = Fock(4, 0) + Fock(0, 4)\nprint(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out)}\")\n</pre> state_in = Fock(2, 2) state_out = Fock(4, 0) + Fock(0, 4) print(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out)}\") <pre>In invariant = 0.2000000 \t Out invariant = 0.2000000\n\nForbidden transition? False\n</pre> In\u00a0[11]: Copied! <pre>state_in = Fock(3, 3)\nstate_out = Fock(6, 0) + Fock(0, 6)\nprint(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out)}\")\n</pre> state_in = Fock(3, 3) state_out = Fock(6, 0) + Fock(0, 6) print(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out)}\") <pre>In invariant = 0.1428571 \t Out invariant = 0.1428571\n\nForbidden transition? False\n</pre> In\u00a0[12]: Copied! <pre>state_in = Fock(4, 4)\nstate_out = Fock(8, 0) + Fock(0, 8)\nprint(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out)}\")\n</pre> state_in = Fock(4, 4) state_out = Fock(8, 0) + Fock(0, 8) print(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out)}\") <pre>In invariant = 0.1111111 \t Out invariant = 0.1111111\n\nForbidden transition? False\n</pre> In\u00a0[13]: Copied! <pre>state_in = Fock(5, 5)\nstate_out = Fock(10, 0) + Fock(0, 10)\nprint(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out)}\")\n</pre> state_in = Fock(5, 5) state_out = Fock(10, 0) + Fock(0, 10) print(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out)}\") <pre>In invariant = 0.0909091 \t Out invariant = 0.0909091\n\nForbidden transition? False\n</pre> <p>We can call the reduced invariant using the <code>method='reduced'</code> option in the functions <code>can_transition</code> and <code>invariant</code>.</p> In\u00a0[14]: Copied! <pre>state = Fock(0, 2)\nprint(f\"tangent_invariant = {photon_invariant(state, method='reduced')}\")\n</pre> state = Fock(0, 2) print(f\"tangent_invariant = {photon_invariant(state, method='reduced')}\") <pre>tangent_invariant = 0.0\n</pre> <p>For pure states, we can recover the full invariant using theorem 2 without using the algebra basis:</p> In\u00a0[15]: Copied! <pre>state = Fock(0, 2)\nprint(f\"tangent_invariant = {photon_invariant(state, method='no basis')}\")\n</pre> state = Fock(0, 2) print(f\"tangent_invariant = {photon_invariant(state, method='no basis')}\") <pre>tangent_invariant = 0.8333333333333334\n</pre> <p>The reduced invariant allows us to apply the invariant criterion</p> In\u00a0[16]: Copied! <pre>state_in = Fock(4, 4)\nstate_out = Fock(8, 0) + Fock(0, 8)\nprint(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out, method='reduced')}\")\n</pre> state_in = Fock(4, 4) state_out = Fock(8, 0) + Fock(0, 8) print(f\"\\nForbidden transition? {forbidden_transition(state_in, state_out, method='reduced')}\") <pre>In reduced invariant = -16.0000000\t Out reduced invariant = -16.0000000\n\nForbidden transition? False\n</pre> In\u00a0[17]: Copied! <pre>not_forbidden = []\nrandom_draws = 1000\nmax_photons_per_mode = 14\nrng = np.random.default_rng()\nmin_modes = 2\nmax_modes = 25\nfor modes in range(min_modes, max_modes):\n    for _ in range(random_draws):\n        while True:\n            photons_in = rng.integers(low=0, high=max_photons_per_mode, size=modes, endpoint=True)\n            photons_out = rng.integers(low=0, high=max_photons_per_mode, size=modes - 1, endpoint=True)\n            if sum(photons_in) &gt;= sum(photons_out):\n                photons_out = np.r_[photons_out, sum(photons_in) - sum(photons_out)]\n                if (np.sort(photons_in) != np.sort(photons_out)).all():\n                    state_in = Fock(*photons_in)\n                    state_out = Fock(*photons_out)\n                    break\n        if not forbidden_transition(state_in, state_out, method=\"reduced\", print_invariant=False):\n            not_forbidden.append((state_in, state_out))\n\nprint(f\"\\nPercentage of not forbidden transitions = {len(not_forbidden) * 100 / (random_draws * (max_modes - min_modes))} %\")\n</pre> not_forbidden = [] random_draws = 1000 max_photons_per_mode = 14 rng = np.random.default_rng() min_modes = 2 max_modes = 25 for modes in range(min_modes, max_modes):     for _ in range(random_draws):         while True:             photons_in = rng.integers(low=0, high=max_photons_per_mode, size=modes, endpoint=True)             photons_out = rng.integers(low=0, high=max_photons_per_mode, size=modes - 1, endpoint=True)             if sum(photons_in) &gt;= sum(photons_out):                 photons_out = np.r_[photons_out, sum(photons_in) - sum(photons_out)]                 if (np.sort(photons_in) != np.sort(photons_out)).all():                     state_in = Fock(*photons_in)                     state_out = Fock(*photons_out)                     break         if not forbidden_transition(state_in, state_out, method=\"reduced\", print_invariant=False):             not_forbidden.append((state_in, state_out))  print(f\"\\nPercentage of not forbidden transitions = {len(not_forbidden) * 100 / (random_draws * (max_modes - min_modes))} %\") <pre>\nPercentage of not forbidden transitions = 0.16521739130434782 %\n</pre> In\u00a0[18]: Copied! <pre>for n in range(5):\n    for k in range(1, n):\n        state_in = Fock(n, 0)\n        state_out = Fock(n - k, k)\n        print(\n            f\"Forbidden transition? {forbidden_transition(state_in, state_out, method='reduced')}\\n\"\n        )\n</pre> for n in range(5):     for k in range(1, n):         state_in = Fock(n, 0)         state_out = Fock(n - k, k)         print(             f\"Forbidden transition? {forbidden_transition(state_in, state_out, method='reduced')}\\n\"         ) <pre>In reduced invariant = 0.0000000\t Out reduced invariant = -1.0000000\nForbidden transition? True\n\nIn reduced invariant = 0.0000000\t Out reduced invariant = -2.0000000\nForbidden transition? True\n\nIn reduced invariant = 0.0000000\t Out reduced invariant = -2.0000000\nForbidden transition? True\n\nIn reduced invariant = 0.0000000\t Out reduced invariant = -3.0000000\nForbidden transition? True\n\nIn reduced invariant = 0.0000000\t Out reduced invariant = -4.0000000\nForbidden transition? True\n\nIn reduced invariant = 0.0000000\t Out reduced invariant = -3.0000000\nForbidden transition? True\n\n</pre> In\u00a0[19]: Copied! <pre>rng = np.random.default_rng()\n\nbell_state = (Fock(1, 0, 1, 0) + Fock(0, 1, 0, 1)) / np.sqrt(2)\nfor modes in range(5, 8):\n    for max_photons_per_mode in range(1, 4):\n        while True:\n            photons_in = rng.integers(low=0, high=max_photons_per_mode, size=modes, endpoint=True)\n            photons_out = rng.integers(\n                low=0, high=max_photons_per_mode, size=modes - 4, endpoint=True\n            )\n            if sum(photons_in) - 2 == sum(photons_out) and sum(photons_in) != 0:\n                state_in = Fock(*photons_in)\n                state_out = bell_state * Fock(*photons_out)\n                break\n        print(\n            f\"Forbidden transition? {forbidden_transition(state_in, state_out, method='reduced')}\\n\"\n        )\n</pre> rng = np.random.default_rng()  bell_state = (Fock(1, 0, 1, 0) + Fock(0, 1, 0, 1)) / np.sqrt(2) for modes in range(5, 8):     for max_photons_per_mode in range(1, 4):         while True:             photons_in = rng.integers(low=0, high=max_photons_per_mode, size=modes, endpoint=True)             photons_out = rng.integers(                 low=0, high=max_photons_per_mode, size=modes - 4, endpoint=True             )             if sum(photons_in) - 2 == sum(photons_out) and sum(photons_in) != 0:                 state_in = Fock(*photons_in)                 state_out = bell_state * Fock(*photons_out)                 break         print(             f\"Forbidden transition? {forbidden_transition(state_in, state_out, method='reduced')}\\n\"         ) <pre>In reduced invariant = -3.0000000\t Out reduced invariant = -3.5000000\nForbidden transition? True\n\nIn reduced invariant = -6.0000000\t Out reduced invariant = -5.5000000\nForbidden transition? True\n\nIn reduced invariant = -8.0000000\t Out reduced invariant = -7.5000000\nForbidden transition? True\n\nIn reduced invariant = -3.0000000\t Out reduced invariant = -3.5000000\nForbidden transition? True\n\nIn reduced invariant = -8.0000000\t Out reduced invariant = -9.5000000\nForbidden transition? True\n\nIn reduced invariant = -9.0000000\t Out reduced invariant = -9.5000000\nForbidden transition? True\n\nIn reduced invariant = -6.0000000\t Out reduced invariant = -6.5000000\nForbidden transition? True\n\nIn reduced invariant = -14.0000000\t Out reduced invariant = -14.5000000\nForbidden transition? True\n\nIn reduced invariant = -31.0000000\t Out reduced invariant = -31.5000000\nForbidden transition? True\n\n</pre> In\u00a0[20]: Copied! <pre>rng = np.random.default_rng()\n\nghz_state = (Fock(1, 0, 1, 0, 1, 0) + Fock(0, 1, 0, 1, 0, 1)) / np.sqrt(2)\nw_state = (Fock(1, 0, 0, 1, 0, 1) + Fock(0, 1, 1, 0, 0, 1) + Fock(0, 1, 0, 1, 1, 0)) / np.sqrt(3)\n\nfor modes in range(1, 5):\n    for max_photons_per_mode in range(1, 4):\n        while True:\n            photons_in = rng.integers(low=0, high=max_photons_per_mode, size=modes, endpoint=True)\n            photons_out = rng.integers(low=0, high=max_photons_per_mode, size=modes, endpoint=True)\n            if sum(photons_in) == sum(photons_out) and sum(photons_in) != 0:\n                state_in = ghz_state * Fock(*photons_in)\n                state_out = w_state * Fock(*photons_out)\n                break\n        print(\n            f\"Forbidden transition? {forbidden_transition(state_in, state_out, method='reduced')}\\n\"\n        )\n</pre> rng = np.random.default_rng()  ghz_state = (Fock(1, 0, 1, 0, 1, 0) + Fock(0, 1, 0, 1, 0, 1)) / np.sqrt(2) w_state = (Fock(1, 0, 0, 1, 0, 1) + Fock(0, 1, 1, 0, 0, 1) + Fock(0, 1, 0, 1, 1, 0)) / np.sqrt(3)  for modes in range(1, 5):     for max_photons_per_mode in range(1, 4):         while True:             photons_in = rng.integers(low=0, high=max_photons_per_mode, size=modes, endpoint=True)             photons_out = rng.integers(low=0, high=max_photons_per_mode, size=modes, endpoint=True)             if sum(photons_in) == sum(photons_out) and sum(photons_in) != 0:                 state_in = ghz_state * Fock(*photons_in)                 state_out = w_state * Fock(*photons_out)                 break         print(             f\"Forbidden transition? {forbidden_transition(state_in, state_out, method='reduced')}\\n\"         ) <pre>In reduced invariant = -6.7500000\t Out reduced invariant = -6.6666667\nForbidden transition? True\n\nIn reduced invariant = -6.7500000\t Out reduced invariant = -6.6666667\nForbidden transition? True\n\nIn reduced invariant = -12.7500000\t Out reduced invariant = -12.6666667\nForbidden transition? True\n\nIn reduced invariant = -6.7500000\t Out reduced invariant = -6.6666667\nForbidden transition? True\n\nIn reduced invariant = -6.7500000\t Out reduced invariant = -6.6666667\nForbidden transition? True\n\nIn reduced invariant = -12.7500000\t Out reduced invariant = -12.6666667\nForbidden transition? True\n\nIn reduced invariant = -6.7500000\t Out reduced invariant = -6.6666667\nForbidden transition? True\n\nIn reduced invariant = -10.7500000\t Out reduced invariant = -9.6666667\nForbidden transition? True\n\nIn reduced invariant = -19.7500000\t Out reduced invariant = -19.6666667\nForbidden transition? True\n\nIn reduced invariant = -10.7500000\t Out reduced invariant = -10.6666667\nForbidden transition? True\n\nIn reduced invariant = -34.7500000\t Out reduced invariant = -33.6666667\nForbidden transition? True\n\nIn reduced invariant = -32.7500000\t Out reduced invariant = -34.6666667\nForbidden transition? True\n\n</pre>"},{"location":"examples/article/#examples-for-no-go-theorems-for-photon-state-transformations-in-quantum-linear-optics","title":"Examples for No-go theorems for photon state transformations in quantum linear optics\u00b6","text":""},{"location":"examples/article/#hilbert-space-and-algebra-bases","title":"Hilbert space and algebra bases\u00b6","text":""},{"location":"examples/article/#computing-invariants","title":"Computing invariants\u00b6","text":""},{"location":"examples/article/#fock-state","title":"Fock state\u00b6","text":""},{"location":"examples/article/#hong-ou-mandel","title":"Hong-Ou-Mandel\u00b6","text":""},{"location":"examples/article/#noon-states","title":"NOON states\u00b6","text":""},{"location":"examples/article/#reduced-invariants","title":"Reduced invariants\u00b6","text":""},{"location":"examples/article/#most-transitions-between-fock-states-are-forbidden","title":"Most transitions between fock states are forbidden\u00b6","text":""},{"location":"examples/article/#forbidden-n-0-to-n-k-k-transition","title":"Forbidden (n, 0) to (n-k, k) transition\u00b6","text":""},{"location":"examples/article/#impossibility-of-bell-state-with-fock-ancilla-generation-from-a-fock-state","title":"Impossibility of Bell state with fock ancilla generation from a fock state\u00b6","text":""},{"location":"examples/article/#impossibility-of-exact-transformation-of-ghz-into-w-with-fock-ancillas","title":"Impossibility of exact transformation of GHZ into W (with fock ancillas)\u00b6","text":""},{"location":"examples/evolution/","title":"Photonic homomorphism","text":"In\u00a0[1]: Copied! <pre>from qoptcraft.operators import haar_random_unitary\nfrom qoptcraft.evolution import photon_unitary\n</pre> from qoptcraft.operators import haar_random_unitary from qoptcraft.evolution import photon_unitary In\u00a0[9]: Copied! <pre>modes = 2\nphotons = 2\nscattering = haar_random_unitary(modes)\n</pre> modes = 2 photons = 2 scattering = haar_random_unitary(modes) In\u00a0[10]: Copied! <pre>photon_unitary(scattering, photons, method=\"heisenberg\")\n</pre> photon_unitary(scattering, photons, method=\"heisenberg\") Out[10]: <pre>array([[ 0.08646906-0.17953484j,  0.2982951 -0.4797357j ,\n         0.49329764-0.6307309j ],\n       [ 0.5622873 +0.05439995j,  0.5889957 +0.12178438j,\n        -0.5377542 -0.1730514j ],\n       [ 0.20271395+0.7746425j , -0.08358276-0.55869514j,\n         0.00817918+0.19910489j]], dtype=complex64)</pre> In\u00a0[13]: Copied! <pre>photon_unitary(scattering, photons, method=\"hamiltonian\")\n</pre> photon_unitary(scattering, photons, method=\"hamiltonian\") Out[13]: <pre>array([[ 0.08646906-0.17953483j,  0.29829512-0.4797357j ,\n         0.49329763-0.6307309j ],\n       [ 0.56228727+0.05439995j,  0.58899569+0.12178438j,\n        -0.53775416-0.1730514j ],\n       [ 0.20271395+0.77464255j, -0.08358276-0.55869513j,\n         0.00817918+0.19910489j]])</pre> In\u00a0[14]: Copied! <pre>photon_unitary(scattering, photons, method=\"permanent glynn\")\n</pre> photon_unitary(scattering, photons, method=\"permanent glynn\") Out[14]: <pre>array([[ 0.08646906-0.17953483j,  0.29829512-0.4797357j ,\n         0.49329763-0.6307309j ],\n       [ 0.56228727+0.05439995j,  0.58899569+0.12178438j,\n        -0.53775416-0.1730514j ],\n       [ 0.20271395+0.77464255j, -0.08358276-0.55869513j,\n         0.00817918+0.19910489j]])</pre> In\u00a0[15]: Copied! <pre>photon_unitary(scattering, photons, method=\"permanent ryser\")\n</pre> photon_unitary(scattering, photons, method=\"permanent ryser\") Out[15]: <pre>array([[ 0.08646906-0.17953483j,  0.29829512-0.4797357j ,\n         0.49329763-0.6307309j ],\n       [ 0.56228727+0.05439995j,  0.58899569+0.12178438j,\n        -0.53775416-0.1730514j ],\n       [ 0.20271395+0.77464255j, -0.08358276-0.55869513j,\n         0.00817918+0.19910489j]])</pre> In\u00a0[4]: Copied! <pre>from qoptcraft import haar_random_unitary, photon_unitary, scattering_from_unitary\n</pre> from qoptcraft import haar_random_unitary, photon_unitary, scattering_from_unitary In\u00a0[5]: Copied! <pre>modes = 2\nphotons = 2\nS = haar_random_unitary(modes)\nprint(S)\n</pre> modes = 2 photons = 2 S = haar_random_unitary(modes) print(S) <pre>[[ 0.56177113-0.56664099j -0.49580864-0.34279j   ]\n [-0.59814006-0.07456307j -0.04159223-0.79683053j]]\n</pre> In\u00a0[6]: Copied! <pre>U = photon_unitary(S, photons)\nS_rebuilt = scattering_from_unitary(U, modes, photons)\nprint(S_rebuilt)\n</pre> U = photon_unitary(S, photons) S_rebuilt = scattering_from_unitary(U, modes, photons) print(S_rebuilt) <pre>[[ 0.79791529+0.j         -0.10564042-0.59344022j]\n [-0.36816856-0.47726628j  0.5365877 -0.5905442j ]]\n</pre> <p>We can check that both matrices are proportional:</p> In\u00a0[7]: Copied! <pre>S.conj().T @ S_rebuilt\n</pre> S.conj().T @ S_rebuilt Out[7]: <pre>array([[ 7.04048577e-01+7.10151815e-01j, -1.11022302e-16+1.73472348e-16j],\n       [ 2.77555756e-16-8.32667268e-17j,  7.04048577e-01+7.10151815e-01j]])</pre>"},{"location":"examples/evolution/#scattering-optical-matrix-to-unitary","title":"Scattering optical matrix to unitary\u00b6","text":""},{"location":"examples/evolution/#unitary-matrix-to-scattering-optical-matrix","title":"Unitary matrix to scattering optical matrix\u00b6","text":""},{"location":"examples/optical_decomp/","title":"Optical decomp","text":"In\u00a0[9]: Copied! <pre>import numpy as np\n\nfrom qoptcraft.optical_elements import clemens_decomposition, reck_decomposition\nfrom qoptcraft.operators import haar_random_unitary\n</pre> import numpy as np  from qoptcraft.optical_elements import clemens_decomposition, reck_decomposition from qoptcraft.operators import haar_random_unitary <p>To perform the clemens decomposition of a unitary matrix into beamsplitters and phase shifters we simply use the function</p> In\u00a0[13]: Copied! <pre>dim = 10\ninterferometer = haar_random_unitary(dim)\nleft_list, diag, right_list = clemens_decomposition(interferometer)\n</pre> dim = 10 interferometer = haar_random_unitary(dim) left_list, diag, right_list = clemens_decomposition(interferometer) <p>We can check that the decomposition was correct:</p> In\u00a0[14]: Copied! <pre>clemens_list = [*left_list, diag, *right_list]\n\nrecomposition = np.eye(dim)\nfor matrix in clemens_list:\n    recomposition = recomposition @ matrix\nnp.testing.assert_allclose(recomposition, interferometer, atol=1e-7, rtol=1e-5)\n</pre> clemens_list = [*left_list, diag, *right_list]  recomposition = np.eye(dim) for matrix in clemens_list:     recomposition = recomposition @ matrix np.testing.assert_allclose(recomposition, interferometer, atol=1e-7, rtol=1e-5) In\u00a0[20]: Copied! <pre>dim = 8\ninterferometer = haar_random_unitary(dim)\ndiag, right_list = reck_decomposition(interferometer)\n</pre> dim = 8 interferometer = haar_random_unitary(dim) diag, right_list = reck_decomposition(interferometer) <p>We can check that the decomposition was correct:</p> In\u00a0[21]: Copied! <pre>reck_list = [diag, *right_list]\n\nrecomposition = np.eye(dim)\nfor matrix in reck_list:\n    recomposition = recomposition @ matrix\nnp.testing.assert_allclose(recomposition, interferometer, atol=1e-7, rtol=1e-5)\n</pre> reck_list = [diag, *right_list]  recomposition = np.eye(dim) for matrix in reck_list:     recomposition = recomposition @ matrix np.testing.assert_allclose(recomposition, interferometer, atol=1e-7, rtol=1e-5)"},{"location":"examples/optical_decomp/#decomposing-an-interferometer-into-beamsplitters-and-phase-shifters","title":"Decomposing an interferometer into beamsplitters and phase-shifters\u00b6","text":""},{"location":"examples/optical_decomp/#clemens-decomposition","title":"Clemens decomposition\u00b6","text":""},{"location":"examples/optical_decomp/#reck-decomposition","title":"Reck decomposition\u00b6","text":""},{"location":"examples/state/","title":"Creating states","text":"<p>There are various ways of defining states in QOptCraft. The main type (class) is <code>State</code>, which subclasses into <code>PureState</code> and <code>MixedState</code>. For convenience, we also have a <code>Fock</code> subclass of <code>PureState</code>, which allows us to create pure states in a handy way with sums and products.</p> In\u00a0[39]: Copied! <pre>import numpy as np\nfrom qoptcraft.state import Fock, PureState, MixedState, State\n</pre> import numpy as np from qoptcraft.state import Fock, PureState, MixedState, State <p>Let's define a state using the <code>Fock</code> subclass</p> In\u00a0[40]: Copied! <pre>state = (Fock(1, 0) + Fock(0, 1)) / np.sqrt(2)\nstate\n</pre> state = (Fock(1, 0) + Fock(0, 1)) / np.sqrt(2) state Out[40]: <pre>0.71 * (1, 0) + \n0.71 * (0, 1)</pre> <p>By default, states are normalized conserving the proportions between the coefficients; thus, we can write the previous state as</p> In\u00a0[41]: Copied! <pre>state = Fock(1, 0) + Fock(0, 1)\nstate\n</pre> state = Fock(1, 0) + Fock(0, 1) state Out[41]: <pre>0.71 * (1, 0) + \n0.71 * (0, 1)</pre> <p>This state is not the same as</p> In\u00a0[42]: Copied! <pre>state = Fock(1, 0) + 2 * Fock(0, 1)\nstate\n</pre> state = Fock(1, 0) + 2 * Fock(0, 1) state Out[42]: <pre>0.45 * (1, 0) + \n0.89 * (0, 1)</pre> <p>The class keeps track of both the coefficients and the amplitudes:</p> In\u00a0[43]: Copied! <pre>print(f\"coefficients = {state.coefs}\")\nprint(f\"amplitudes = {state.amplitudes}\")\n</pre> print(f\"coefficients = {state.coefs}\") print(f\"amplitudes = {state.amplitudes}\") <pre>coefficients = [1 2]\namplitudes = [0.4472136  0.89442719]\n</pre> <p>We can also create pure states by initializing the <code>PureState</code> class. This is done providing a list of photon number (fock) states, as a list of tuples, and a list of coefficients.</p> In\u00a0[44]: Copied! <pre>fock_list = [(2, 0), (0, 2)]\ncoef_list = [1 / np.sqrt(2), -1 / np.sqrt(2)]\nPureState(fock_list, coef_list)\n</pre> fock_list = [(2, 0), (0, 2)] coef_list = [1 / np.sqrt(2), -1 / np.sqrt(2)] PureState(fock_list, coef_list) Out[44]: <pre>0.71 * (2, 0) + \n-0.71 * (0, 2)</pre> <p>We can do operations with pure states, like summing or computing tensor products:</p> In\u00a0[45]: Copied! <pre>state_1 = Fock(2, 0) + Fock(0, 2)\nstate_2 = Fock(1, 1)\nstate_1 - state_2\n</pre> state_1 = Fock(2, 0) + Fock(0, 2) state_2 = Fock(1, 1) state_1 - state_2 Out[45]: <pre>0.58 * (2, 0) + \n-0.58 * (1, 1) + \n0.58 * (0, 2)</pre> In\u00a0[46]: Copied! <pre>state_1 * state_2\n</pre> state_1 * state_2 Out[46]: <pre>0.71 * (2, 0, 1, 1) + \n0.71 * (0, 2, 1, 1)</pre> <p>There are a number of attributes we can access, including the number of photons</p> In\u00a0[55]: Copied! <pre>state_1.photons\n</pre> state_1.photons Out[55]: <pre>2</pre> <p>the number of modes</p> In\u00a0[56]: Copied! <pre>state_1.modes\n</pre> state_1.modes Out[56]: <pre>2</pre> <p>and the density matrix</p> In\u00a0[\u00a0]: Copied! <pre>state_1.density_matrix\n</pre> state_1.density_matrix <pre>array([[0.5+0.j, 0. +0.j, 0.5+0.j],\n       [0. +0.j, 0. +0.j, 0. +0.j],\n       [0.5+0.j, 0. +0.j, 0.5+0.j]])</pre> <p>We can retrieve the state in the Fock basis:</p> In\u00a0[48]: Copied! <pre>state_1.state_in_basis()\n</pre> state_1.state_in_basis() Out[48]: <pre>array([0.70710678+0.j, 0.        +0.j, 0.70710678+0.j])</pre> <p>We can apply creation and annihilation operators</p> In\u00a0[49]: Copied! <pre>state = Fock(1, 0) + Fock(0, 1)\nstate.creation(mode=1)\n</pre> state = Fock(1, 0) + Fock(0, 1) state.creation(mode=1) Out[49]: <pre>0.58 * (1, 1) + \n0.82 * (0, 2)</pre> In\u00a0[50]: Copied! <pre>state = Fock(2, 0) + Fock(0, 2)\nstate.annihilation(mode=0)\n</pre> state = Fock(2, 0) + Fock(0, 2) state.annihilation(mode=0) Out[50]: <pre>(1, 0)</pre> <p>Mixed states can be created directly from the density matrix:</p> In\u00a0[53]: Copied! <pre>mixed_state = MixedState(density_matrix=np.eye(3) / 3, modes=2, photons=2)\nmixed_state.density_matrix\n</pre> mixed_state = MixedState(density_matrix=np.eye(3) / 3, modes=2, photons=2) mixed_state.density_matrix Out[53]: <pre>array([[0.33333333, 0.        , 0.        ],\n       [0.        , 0.33333333, 0.        ],\n       [0.        , 0.        , 0.33333333]])</pre> <p>or from a mixture of pure states:</p> In\u00a0[54]: Copied! <pre>mixed_state = MixedState.from_mixture(pure_states=[state_1, state_2], probs=[0.5, 0.5])\nmixed_state.density_matrix\n</pre> mixed_state = MixedState.from_mixture(pure_states=[state_1, state_2], probs=[0.5, 0.5]) mixed_state.density_matrix Out[54]: <pre>array([[0.25+0.j, 0.  +0.j, 0.25+0.j],\n       [0.  +0.j, 0.5 +0.j, 0.  +0.j],\n       [0.25+0.j, 0.  +0.j, 0.25+0.j]])</pre>"},{"location":"examples/state/#defining-states","title":"Defining states\u00b6","text":""},{"location":"examples/state/#pure-states","title":"Pure states\u00b6","text":""},{"location":"examples/state/#initialization","title":"Initialization\u00b6","text":""},{"location":"examples/state/#operations","title":"Operations\u00b6","text":""},{"location":"examples/state/#attributes","title":"Attributes\u00b6","text":""},{"location":"examples/state/#methods","title":"Methods\u00b6","text":""},{"location":"examples/state/#mixed-states","title":"Mixed states\u00b6","text":""},{"location":"examples/toponogov/","title":"Toponogov approximation","text":"In\u00a0[3]: Copied! <pre>from qoptcraft.operators import qft\nfrom qoptcraft.toponogov import toponogov\n</pre> from qoptcraft.operators import qft from qoptcraft.toponogov import toponogov <pre>Basis saved in /Users/milvus/Documents/Code projects/QOptCraft/examples/save_basis/m=3 n=2/photon.pkl.\nBasis saved in /Users/milvus/Documents/Code projects/QOptCraft/examples/save_basis/m=3 n=2\n</pre> <p>We can easily approximate a unitary with a certain error using the function <code>toponogov</code></p> In\u00a0[\u00a0]: Copied! <pre>modes = 3\nphotons = 2\nunitary = qft(6)\napprox_unitary, error = toponogov(unitary, modes, photons)\n</pre> modes = 3 photons = 2 unitary = qft(6) approx_unitary, error = toponogov(unitary, modes, photons) <p>We can iterate for different seeds:</p> In\u00a0[10]: Copied! <pre>min_error = 10\nfor seed in range(300):\n    approx_unitary, error = toponogov(unitary, modes, photons, seed=seed)\n    if error &lt; min_error:\n        min_approx_unitary = approx_unitary\n        min_error = error\n</pre> min_error = 10 for seed in range(300):     approx_unitary, error = toponogov(unitary, modes, photons, seed=seed)     if error &lt; min_error:         min_approx_unitary = approx_unitary         min_error = error In\u00a0[13]: Copied! <pre>min_error\n</pre> min_error Out[13]: <pre>2.1494761713199346</pre>"},{"location":"examples/toponogov/#approximate-a-unitary-with-linear-optics-using-toponogovs-theorem","title":"Approximate a unitary with linear optics using Toponogov's theorem\u00b6","text":""},{"location":"reference/","title":"qoptcraft","text":""},{"location":"reference/#qoptcraft","title":"<code>qoptcraft</code>","text":""},{"location":"reference/_version/","title":"_version","text":""},{"location":"reference/_version/#qoptcraft._version","title":"<code>qoptcraft._version</code>","text":"<p>Version number (major.minor.patch)</p>"},{"location":"reference/config/","title":"config","text":""},{"location":"reference/config/#qoptcraft.config","title":"<code>qoptcraft.config</code>","text":""},{"location":"reference/basis/","title":"basis","text":""},{"location":"reference/basis/#qoptcraft.basis","title":"<code>qoptcraft.basis</code>","text":""},{"location":"reference/basis/algebra/","title":"algebra","text":""},{"location":"reference/basis/algebra/#qoptcraft.basis.algebra","title":"<code>qoptcraft.basis.algebra</code>","text":""},{"location":"reference/basis/algebra/#qoptcraft.basis.algebra.algebra_basis","title":"<code>algebra_basis(modes, photons)</code>","text":"<p>Generate the basis for the algebra and image algebra.</p> Source code in <code>qoptcraft/basis/algebra.py</code> <pre><code>def algebra_basis(modes: int, photons: int) -&gt; tuple[BasisAlgebra, BasisAlgebra]:\n\"\"\"Generate the basis for the algebra and image algebra.\"\"\"\n    basis = []\n    basis_image = []\n    photon_basis = get_photon_basis(modes, photons)\n\n    for mode_1 in range(modes):\n        for mode_2 in range(mode_1 + 1):\n            matrix = sym_matrix(mode_1, mode_2, modes)\n            basis.append(matrix)\n            basis_image.append(image_sym_matrix(mode_1, mode_2, photon_basis))\n\n    # Divide into two loops to separate symmetric from antisymmetric matrices\n    for mode_1 in range(modes):\n        for mode_2 in range(mode_1):\n            matrix = antisym_matrix(mode_1, mode_2, modes)\n            basis.append(matrix)\n            basis_image.append(image_antisym_matrix(mode_1, mode_2, photon_basis))\n\n    return basis, basis_image\n</code></pre>"},{"location":"reference/basis/algebra/#qoptcraft.basis.algebra.antisym_matrix","title":"<code>antisym_matrix(mode_1, mode_2, dim)</code>","text":"<p>Create the element of the algebra 1/2(|j&gt;&lt;j|). Source code in <code>qoptcraft/basis/algebra.py</code> <pre><code>def antisym_matrix(mode_1: int, mode_2: int, dim: int) -&gt; spmatrix:\n\"\"\"Create the element of the algebra 1/2(|j&gt;&lt;k| - |k&gt;&lt;j|).\"\"\"\n    matrix = np.zeros((dim, dim), dtype=np.complex128)\n    matrix[mode_1, mode_2] = 0.5\n    matrix[mode_2, mode_1] = -0.5\n    return matrix\n</code></pre>"},{"location":"reference/basis/algebra/#qoptcraft.basis.algebra.get_algebra_basis","title":"<code>get_algebra_basis(modes, photons)</code>","text":"<p>Return a basis for the Hilbert space with n photons and m modes. If the basis was saved retrieve it, otherwise the function creates and saves the basis to a file.</p> <p>Parameters:</p> Name Type Description Default <code>photons</code> <code>int</code> <p>number of photons.</p> required <code>modes</code> <code>int</code> <p>number of modes.</p> required <p>Returns:</p> Type Description <code>tuple[BasisAlgebra, BasisAlgebra]</code> <p>BasisAlgebra, BasisAlgebra: basis of the algebra and the image algebra.</p> Source code in <code>qoptcraft/basis/algebra.py</code> <pre><code>def get_algebra_basis(modes: int, photons: int) -&gt; tuple[BasisAlgebra, BasisAlgebra]:\n\"\"\"Return a basis for the Hilbert space with n photons and m modes.\n    If the basis was saved retrieve it, otherwise the function creates\n    and saves the basis to a file.\n\n    Args:\n        photons (int): number of photons.\n        modes (int): number of modes.\n\n    Returns:\n        BasisAlgebra, BasisAlgebra: basis of the algebra and the image algebra.\n    \"\"\"\n    folder_path = config.SAVE_DATA_PATH / f\"m={modes} n={photons}\"\n    folder_path.mkdir(parents=True, exist_ok=True)\n\n    basis_path = folder_path / \"algebra.pkl\"\n    basis_image_path = folder_path / \"image_algebra.pkl\"\n    basis_path.touch()  # create file if it doesn't exist\n    basis_image_path.touch()\n    try:\n        with basis_path.open(\"rb\") as f:\n            basis = pickle.load(f)\n        with basis_image_path.open(\"rb\") as f:\n            basis_image = pickle.load(f)\n\n    except EOFError:\n        basis, basis_image = algebra_basis(modes, photons)\n        with basis_path.open(\"wb\") as f:\n            pickle.dump(basis, f)\n        with basis_image_path.open(\"wb\") as f:\n            pickle.dump(basis_image, f)\n        print(f\"Algebra basis saved in {folder_path}\")\n\n    return basis, basis_image\n</code></pre>"},{"location":"reference/basis/algebra/#qoptcraft.basis.algebra.image_antisym_matrix","title":"<code>image_antisym_matrix(mode_1, mode_2, photon_basis)</code>","text":"<p>Image of the antisymmetric basis matrix by the lie algebra homomorphism.</p> Source code in <code>qoptcraft/basis/algebra.py</code> <pre><code>def image_antisym_matrix(mode_1: int, mode_2: int, photon_basis: BasisPhoton) -&gt; spmatrix:\n\"\"\"Image of the antisymmetric basis matrix by the lie algebra homomorphism.\"\"\"\n    dim = len(photon_basis)\n    matrix = lil_matrix((dim, dim), dtype=np.complex128)\n\n    for col, fock_ in enumerate(photon_basis):\n        if fock_[mode_1] != 0:\n            fock, coef = annihilation(mode_1, fock_)\n            fock, coef_ = creation(mode_2, fock)\n            matrix[photon_basis.index(fock), col] = -0.5 * coef * coef_\n\n        if fock_[mode_2] != 0:\n            fock, coef = annihilation(mode_2, fock_)\n            fock, coef_ = creation(mode_1, fock)\n            matrix[photon_basis.index(fock), col] += 0.5 * coef * coef_\n\n    return matrix.tocsr()\n</code></pre>"},{"location":"reference/basis/algebra/#qoptcraft.basis.algebra.image_sym_matrix","title":"<code>image_sym_matrix(mode_1, mode_2, photon_basis)</code>","text":"<p>Image of the symmetric basis matrix by the lie algebra homomorphism.</p> Source code in <code>qoptcraft/basis/algebra.py</code> <pre><code>def image_sym_matrix(mode_1: int, mode_2: int, photon_basis: BasisPhoton) -&gt; spmatrix:\n\"\"\"Image of the symmetric basis matrix by the lie algebra homomorphism.\"\"\"\n    dim = len(photon_basis)\n    matrix = lil_matrix((dim, dim), dtype=np.complex128)  # * efficient format for loading data\n\n    for col, fock_ in enumerate(photon_basis):\n        if fock_[mode_1] != 0:\n            fock, coef = annihilation(mode_1, fock_)\n            fock, coef_ = creation(mode_2, fock)\n            matrix[photon_basis.index(fock), col] = 0.5j * coef * coef_\n\n        if fock_[mode_2] != 0:\n            fock, coef = annihilation(mode_2, fock_)\n            fock, coef_ = creation(mode_1, fock)\n            matrix[photon_basis.index(fock), col] += 0.5j * coef * coef_\n\n    return matrix.tocsr()\n</code></pre>"},{"location":"reference/basis/algebra/#qoptcraft.basis.algebra.sym_matrix","title":"<code>sym_matrix(mode_1, mode_2, dim)</code>","text":"<p>Create the element of the algebra i/2(|j&gt;&lt;j|). Source code in <code>qoptcraft/basis/algebra.py</code> <pre><code>def sym_matrix(mode_1: int, mode_2: int, dim: int) -&gt; spmatrix:\n\"\"\"Create the element of the algebra i/2(|j&gt;&lt;k| + |k&gt;&lt;j|).\"\"\"\n    matrix = np.zeros((dim, dim), dtype=np.complex128)\n    matrix[mode_1, mode_2] = 0.5j\n    matrix[mode_2, mode_1] += 0.5j\n    return matrix\n</code></pre>"},{"location":"reference/basis/hilbert_dimension/","title":"hilbert_dimension","text":""},{"location":"reference/basis/hilbert_dimension/#qoptcraft.basis.hilbert_dimension","title":"<code>qoptcraft.basis.hilbert_dimension</code>","text":""},{"location":"reference/basis/hilbert_dimension/#qoptcraft.basis.hilbert_dimension.hilbert_dim","title":"<code>hilbert_dim(modes, photons)</code>","text":"<p>Dimension of the Hilbert space with m modes and n photons.</p> <p>Parameters:</p> Name Type Description Default <code>modes</code> <code>int</code> <p>number of modes.</p> required <code>photons</code> <code>int</code> <p>number of photons.</p> required <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>dimension.</p> Source code in <code>qoptcraft/basis/hilbert_dimension.py</code> <pre><code>def hilbert_dim(modes: int, photons: int) -&gt; int:\n\"\"\"Dimension of the Hilbert space with m modes and n photons.\n\n    Args:\n        modes (int): number of modes.\n        photons (int): number of photons.\n\n    Returns:\n        int: dimension.\n    \"\"\"\n    return int(comb(modes + photons - 1, photons))\n</code></pre>"},{"location":"reference/basis/photon/","title":"photon","text":""},{"location":"reference/basis/photon/#qoptcraft.basis.photon","title":"<code>qoptcraft.basis.photon</code>","text":""},{"location":"reference/basis/photon/#qoptcraft.basis.photon.get_photon_basis","title":"<code>get_photon_basis(modes, photons)</code>","text":"<p>Return a basis for the Hilbert space with n photons and m modes. If the basis was saved retrieve it, otherwise the function creates and saves the basis to a file.</p> <p>Parameters:</p> Name Type Description Default <code>photons</code> <code>int</code> <p>number of photons.</p> required <code>modes</code> <code>int</code> <p>number of modes.</p> required <p>Returns:</p> Name Type Description <code>BasisPhoton</code> <code>BasisPhoton</code> <p>basis of the Hilbert space.</p> Source code in <code>qoptcraft/basis/photon.py</code> <pre><code>def get_photon_basis(modes: int, photons: int) -&gt; BasisPhoton:\n\"\"\"Return a basis for the Hilbert space with n photons and m modes.\n    If the basis was saved retrieve it, otherwise the function creates\n    and saves the basis to a file.\n\n    Args:\n        photons (int): number of photons.\n        modes (int): number of modes.\n\n    Returns:\n        BasisPhoton: basis of the Hilbert space.\n    \"\"\"\n    folder_path = config.SAVE_DATA_PATH / f\"m={modes} n={photons}\"\n    folder_path.mkdir(parents=True, exist_ok=True)\n    basis_path = folder_path / \"photon.pkl\"\n    basis_path.touch()\n\n    try:\n        with basis_path.open(\"rb\") as f:\n            basis = pickle.load(f)\n\n    except EOFError:\n        basis = photon_basis(modes, photons)\n        with basis_path.open(\"wb\") as f:\n            pickle.dump(basis, f)\n        print(f\"Photon basis saved in {basis_path}.\")\n\n    return basis\n</code></pre>"},{"location":"reference/basis/photon/#qoptcraft.basis.photon.photon_basis","title":"<code>photon_basis(modes, photons)</code>","text":"<p>Given a number of photons and modes, generate the basis of the Hilbert space.</p> <p>Parameters:</p> Name Type Description Default <code>photons</code> <code>int</code> <p>number of photons.</p> required <code>modes</code> <code>int</code> <p>number of modes.</p> required <p>Returns:</p> Name Type Description <code>BasisPhoton</code> <code>BasisPhoton</code> <p>basis of the Hilbert space.</p> Source code in <code>qoptcraft/basis/photon.py</code> <pre><code>def photon_basis(modes: int, photons: int) -&gt; BasisPhoton:\n\"\"\"Given a number of photons and modes, generate the basis of the Hilbert space.\n\n    Args:\n        photons (int): number of photons.\n        modes (int): number of modes.\n\n    Returns:\n        BasisPhoton: basis of the Hilbert space.\n    \"\"\"\n    if photons &lt; 0:\n        photons = 0\n    if modes == 1:\n        return [(photons,)]\n\n    new_basis = []\n    for n in range(photons, -1, -1):\n        basis = photon_basis(modes - 1, photons - n)\n        for vector in basis:\n            new_basis.append((n, *vector))\n    return new_basis\n</code></pre>"},{"location":"reference/evolution/","title":"evolution","text":""},{"location":"reference/evolution/#qoptcraft.evolution","title":"<code>qoptcraft.evolution</code>","text":""},{"location":"reference/evolution/fock_evolution/","title":"fock_evolution","text":""},{"location":"reference/evolution/fock_evolution/#qoptcraft.evolution.fock_evolution","title":"<code>qoptcraft.evolution.fock_evolution</code>","text":""},{"location":"reference/evolution/fock_evolution/#qoptcraft.evolution.fock_evolution.fock_evolution","title":"<code>fock_evolution(scattering_matrix, fock_in, method='permanent glynn')</code>","text":"<p>Evolution of a single Fock state using the definition given by basic quantum mechanics.</p> <p>Parameters:</p> Name Type Description Default <code>scattering_matrix</code> <code>NDArray</code> <p>scattering matrix of a linear optical interferometer.</p> required <code>fock_in</code> <code>Fock</code> <p>fock state to evolve.</p> required <code>method</code> <code>str</code> <p>method to calculate the evolution of the Fock state. Options are 'heisenberg', 'permanent glynn' or 'permanent ryser'. Default is 'permanent glynn'.</p> <code>'permanent glynn'</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>fock state given in the photon basis.</p> Source code in <code>qoptcraft/evolution/fock_evolution.py</code> <pre><code>def fock_evolution(\n    scattering_matrix: NDArray,\n    fock_in: tuple[int, ...],\n    method: Literal[\"heisenberg\", \"permanent glynn\", \"permanent ryser\"] = \"permanent glynn\",\n) -&gt; NDArray:\n\"\"\"Evolution of a single Fock state using the definition given by basic\n    quantum mechanics.\n\n    Args:\n        scattering_matrix (NDArray): scattering matrix of a linear optical interferometer.\n        fock_in (Fock): fock state to evolve.\n        method (str): method to calculate the evolution of the Fock state. Options are\n            'heisenberg', 'permanent glynn' or 'permanent ryser'. Default is 'permanent glynn'.\n\n    Returns:\n        NDArray: fock state given in the photon basis.\n    \"\"\"\n    if method == \"heisenberg\":\n        return fock_evolution_heisenberg(scattering_matrix, fock_in)\n    if method.split()[0] == \"permanent\":\n        return fock_evolution_permanent(scattering_matrix, fock_in, method=method.split()[1])\n    raise ValueError(\"Options for method are 'heisenberg', 'permanent glynn' or 'permanent ryser'.\")\n</code></pre>"},{"location":"reference/evolution/fock_evolution/#qoptcraft.evolution.fock_evolution.fock_evolution_heisenberg","title":"<code>fock_evolution_heisenberg(scattering_matrix, fock_in)</code>","text":"<p>Evolution of a single Fock state using the definition given by basic quantum mechanics.</p> <p>Parameters:</p> Name Type Description Default <code>scattering_matrix</code> <code>NDArray</code> <p>scattering matrix of a linear optical interferometer.</p> required <code>fock_in</code> <code>Fock</code> <p>fock state to evolve.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>fock state given in the photon basis.</p> Source code in <code>qoptcraft/evolution/fock_evolution.py</code> <pre><code>def fock_evolution_heisenberg(scattering_matrix: NDArray, fock_in: tuple[int, ...]) -&gt; NDArray:\n\"\"\"Evolution of a single Fock state using the definition given by basic\n    quantum mechanics.\n\n    Args:\n        scattering_matrix (NDArray): scattering matrix of a linear optical interferometer.\n        fock_in (Fock): fock state to evolve.\n\n    Returns:\n        NDArray: fock state given in the photon basis.\n    \"\"\"\n    modes = len(fock_in)\n\n    state_out: PureState = Fock(*([0] * modes))\n    for mode_2 in range(modes):\n        for _ in range(fock_in[mode_2]):\n            state_aux = state_out\n            state_out = scattering_matrix[0, mode_2] * state_aux.creation(0)\n            for mode_1 in range(1, modes):\n                state_out += scattering_matrix[mode_1, mode_2] * state_aux.creation(mode_1)\n    coef = np.prod(factorial(fock_in))\n    return state_out / np.sqrt(coef)\n</code></pre>"},{"location":"reference/evolution/fock_evolution/#qoptcraft.evolution.fock_evolution.fock_evolution_permanent","title":"<code>fock_evolution_permanent(scattering_matrix, fock_in, method='glynn', photon_basis=None)</code>","text":"<p>Evolution of a single Fock state using the definition given by basic quantum mechanics.</p> <p>Parameters:</p> Name Type Description Default <code>scattering_matrix</code> <code>NDArray</code> <p>scattering matrix of a linear optical interferometer.</p> required <code>fock_in</code> <code>Fock</code> <p>fock state to evolve.</p> required <code>method</code> <code>str</code> <p>method to compute the permanent. Must be 'glynn' or 'ryser'. Defaults to 'glynn'.</p> <code>'glynn'</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>fock state given in the photon basis.</p> Source code in <code>qoptcraft/evolution/fock_evolution.py</code> <pre><code>def fock_evolution_permanent(\n    scattering_matrix: NDArray,\n    fock_in: tuple[int, ...],\n    method: Literal[\"glynn\", \"ryser\"] = \"glynn\",\n    photon_basis: BasisPhoton = None,\n) -&gt; NDArray:\n\"\"\"Evolution of a single Fock state using the definition given by basic\n    quantum mechanics.\n\n    Args:\n        scattering_matrix (NDArray): scattering matrix of a linear optical interferometer.\n        fock_in (Fock): fock state to evolve.\n        method (str): method to compute the permanent. Must be 'glynn' or 'ryser'.\n            Defaults to 'glynn'.\n\n    Returns:\n        NDArray: fock state given in the photon basis.\n    \"\"\"\n    if len(fock_in) != scattering_matrix.shape[0]:\n        raise ValueError(\"Dimension of scattering_matrix and number of modes don't match.\")\n    if photon_basis is None:\n        photon_basis = get_photon_basis(len(fock_in), sum(fock_in))\n    dim = len(photon_basis)\n    state_out = np.empty(dim, dtype=np.complex128)\n\n    for row, fock_out in enumerate(photon_basis):\n        sub_matrix = in_out_submatrix(scattering_matrix, fock_in, fock_out)\n        coef = np.prod(factorial(fock_in)) * np.prod(factorial(fock_out))\n        state_out[row] = permanent(sub_matrix, method=method) / np.sqrt(coef)\n    return state_out\n</code></pre>"},{"location":"reference/evolution/fock_evolution/#qoptcraft.evolution.fock_evolution.in_out_submatrix","title":"<code>in_out_submatrix(matrix, fock_in, fock_out)</code>","text":"<p>Return a matrix with row index 'i' repeated 'row_rep' times and column index 'j' repeated 'col_rep' times.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>m, m) array</code> <p>Linear optical scattering matrix with m modes.</p> required <p>Returns:</p> Type Description <code>NDArray</code> <p>(n, n) array: Optical scattering matrix with m modes and n photons.</p> Source code in <code>qoptcraft/evolution/fock_evolution.py</code> <pre><code>@numba.jit(nopython=True)\ndef in_out_submatrix(matrix, fock_in: tuple[int, ...], fock_out: tuple[int, ...]) -&gt; NDArray:\n\"\"\"Return a matrix with row index 'i' repeated 'row_rep' times\n    and column index 'j' repeated 'col_rep' times.\n\n    Args:\n        matrix ((m, m) array): Linear optical scattering matrix with m modes.\n\n    Returns:\n        (n, n) array: Optical scattering matrix with m modes and n photons.\n    \"\"\"\n    modes = len(fock_in)\n    photons = sum(fock_in)\n    interm_matrix = np.empty((matrix.shape[0], photons), dtype=\"complex128\")\n    col = 0\n    for mode in range(modes):\n        for _ in range(fock_in[mode]):\n            interm_matrix[:, col] = matrix[:, mode]\n            col += 1\n    final_matrix = np.empty((photons, photons), dtype=\"complex128\")\n    row = 0\n    for mode in range(modes):\n        for _ in range(fock_out[mode]):\n            final_matrix[row, :] = interm_matrix[mode, :]\n            row += 1\n    return final_matrix\n</code></pre>"},{"location":"reference/evolution/hamiltonian_evolution/","title":"hamiltonian_evolution","text":""},{"location":"reference/evolution/hamiltonian_evolution/#qoptcraft.evolution.hamiltonian_evolution","title":"<code>qoptcraft.evolution.hamiltonian_evolution</code>","text":""},{"location":"reference/evolution/hamiltonian_evolution/#qoptcraft.evolution.hamiltonian_evolution.photon_hamiltonian","title":"<code>photon_hamiltonian(scattering_matrix, photons)</code>","text":"<p>Lift the scattering linear optical matrix to a photonic hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>scattering_matrix</code> <code>NDArray</code> <p>matrix of the linear optical system.</p> required <code>photons</code> <code>int</code> <p>number of photons.</p> required <p>Returns:</p> Name Type Description <code>spmatrix</code> <code>NDArray</code> <p>hamiltonian lifted to the Hilbert space of m modes and n photons.</p> Source code in <code>qoptcraft/evolution/hamiltonian_evolution.py</code> <pre><code>def photon_hamiltonian(scattering_matrix: NDArray, photons: int) -&gt; NDArray:\n\"\"\"Lift the scattering linear optical matrix to a photonic hamiltonian.\n\n    Args:\n        scattering_matrix (NDArray): matrix of the linear optical system.\n        photons (int): number of photons.\n\n    Returns:\n        spmatrix: hamiltonian lifted to the Hilbert space of m modes and n photons.\n    \"\"\"\n    modes = scattering_matrix.shape[0]\n    basis_photon = get_photon_basis(modes, photons)\n    dim = len(basis_photon)\n\n    lifted_matrix = np.zeros((dim, dim), dtype=complex)\n\n    for col_img, fock_ in enumerate(basis_photon):\n        for row in range(modes):\n            for col in range(modes):\n                fock, coef = annihilation(col, fock_)\n                if coef == 0:\n                    continue\n                fock, coef_ = creation(row, fock)\n                coef = coef * coef_ * scattering_matrix[row, col]\n                row_img = basis_photon.index(fock)\n                lifted_matrix[row_img, col_img] += coef\n\n    return lifted_matrix\n</code></pre>"},{"location":"reference/evolution/inverse_problem/","title":"inverse_problem","text":""},{"location":"reference/evolution/inverse_problem/#qoptcraft.evolution.inverse_problem","title":"<code>qoptcraft.evolution.inverse_problem</code>","text":""},{"location":"reference/evolution/inverse_problem/#qoptcraft.evolution.inverse_problem.scattering_from_unitary","title":"<code>scattering_from_unitary(unitary, modes, photons)</code>","text":"<p>Retrieve the linear optical scattering matrix from a unitary using Theorem 2 of PRA 100, 022301 (2019).</p> <p>Parameters:</p> Name Type Description Default <code>unitary</code> <code>NDArray</code> <p>unitary matrix.</p> required <code>modes</code> <code>int</code> <p>number of modes in the optical system.</p> required <code>photons</code> <code>int</code> <p>number of photons.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>optical scattering matrix that maps to the given unitary.</p> Source code in <code>qoptcraft/evolution/inverse_problem.py</code> <pre><code>def scattering_from_unitary(unitary: NDArray, modes: int, photons: int) -&gt; NDArray:\n\"\"\"Retrieve the linear optical scattering matrix from a unitary using Theorem 2\n    of PRA 100, 022301 (2019).\n\n    Args:\n        unitary (NDArray): unitary matrix.\n        modes (int): number of modes in the optical system.\n        photons (int): number of photons.\n\n    Returns:\n        NDArray: optical scattering matrix that maps to the given unitary.\n    \"\"\"\n    coefs = _solution_coefs(unitary, modes, photons)\n    basis, _ = get_algebra_basis(modes, photons)\n\n    basis_array = np.array(basis)\n\n    def adjoint(basis_matrix):\n        for i in range(len(basis)):\n            if (basis_matrix == basis[i]).all():\n                index = i\n                break\n        return np.einsum(\"k,kij-&gt;ij\", coefs[index, :], basis_array)\n\n    identity = np.eye(modes)\n\n    def get_nonzero_element():\n        for j in range(modes):\n            basis_matrix = sym_matrix(j, j, modes)\n            for l in range(modes):\n                ad_matrix = adjoint(basis_matrix)\n                exp_val = np.einsum(\"i,ij,j-&gt;\", identity[l, :], ad_matrix, identity[l, :])\n                if not np.isclose(exp_val, 0, rtol=1e-5, atol=1e-8):\n                    j0, l0 = j, l\n                    coef = np.sqrt(-1j * exp_val)\n                    return j0, l0, coef\n        raise ValueError(\"Nonzero element not found.\")\n\n    j0, l0, coef = get_nonzero_element()\n    scattering = np.zeros((modes, modes), dtype=np.complex128)\n    for l in range(modes):\n        for j in range(modes):\n            ad_sym = adjoint(sym_matrix(j, j0, modes))\n            sym_term = np.einsum(\"i,ij,j-&gt;\", identity[l, :], ad_sym, identity[l0, :])\n            if j != j0:\n                ad_antisym = adjoint(antisym_matrix(j, j0, modes))\n                antisym_term = np.einsum(\n                    \"i,ij,j-&gt;\",\n                    identity[l, :],\n                    ad_antisym,\n                    identity[l0, :],\n                )\n            else:\n                antisym_term = 0\n            scattering[l, j] = (antisym_term - 1j * sym_term) / coef\n    return scattering\n</code></pre>"},{"location":"reference/evolution/photon_hamiltonian/","title":"photon_hamiltonian","text":""},{"location":"reference/evolution/photon_hamiltonian/#qoptcraft.evolution.photon_hamiltonian","title":"<code>qoptcraft.evolution.photon_hamiltonian</code>","text":""},{"location":"reference/evolution/photon_hamiltonian/#qoptcraft.evolution.photon_hamiltonian.photon_hamiltonian","title":"<code>photon_hamiltonian(scattering_matrix, photons)</code>","text":"<p>Lift the scattering linear optical matrix to a photonic hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>scattering_matrix</code> <code>NDArray</code> <p>matrix of the linear optical system.</p> required <code>photons</code> <code>int</code> <p>number of photons.</p> required <p>Returns:</p> Name Type Description <code>spmatrix</code> <code>NDArray</code> <p>hamiltonian lifted to the Hilbert space of m modes and n photons.</p> Source code in <code>qoptcraft/evolution/photon_hamiltonian.py</code> <pre><code>def photon_hamiltonian(scattering_matrix: NDArray, photons: int) -&gt; NDArray:\n\"\"\"Lift the scattering linear optical matrix to a photonic hamiltonian.\n\n    Args:\n        scattering_matrix (NDArray): matrix of the linear optical system.\n        photons (int): number of photons.\n\n    Returns:\n        spmatrix: hamiltonian lifted to the Hilbert space of m modes and n photons.\n    \"\"\"\n    modes = scattering_matrix.shape[0]\n    basis_photon = get_photon_basis(modes, photons)\n    dim = len(basis_photon)\n\n    lifted_matrix = np.zeros((dim, dim), dtype=complex)\n\n    for col_img, fock_ in enumerate(basis_photon):\n        for row in range(modes):\n            for col in range(modes):\n                fock, coef = annihilation(col, fock_)\n                if coef == 0:\n                    continue\n                fock, coef_ = creation(row, fock)\n                coef = coef * coef_ * scattering_matrix[row, col]\n                row_img = basis_photon.index(fock)\n                lifted_matrix[row_img, col_img] += coef\n\n    return lifted_matrix\n</code></pre>"},{"location":"reference/evolution/photon_unitary/","title":"photon_unitary","text":""},{"location":"reference/evolution/photon_unitary/#qoptcraft.evolution.photon_unitary","title":"<code>qoptcraft.evolution.photon_unitary</code>","text":""},{"location":"reference/evolution/photon_unitary/#qoptcraft.evolution.photon_unitary.photon_unitary","title":"<code>photon_unitary(scattering_matrix, photons, method='permanent glynn')</code>","text":"<p>Unitary matrix of a linear interferometer with a number of photons as input.</p> <p>Parameters:</p> Name Type Description Default <code>scattering_matrix</code> <code>NDArray</code> <p>scattering matrix of a linear optical interferometer.</p> required <code>photons</code> <code>int</code> <p>number of photons.</p> required <code>method</code> <code>str</code> <p>method to calculate the multiphoton unitary. Options are 'heisenberg', 'hamiltonian', 'permanent glynn' or 'permanent ryser'. Default is 'permanent glynn'.</p> <code>'permanent glynn'</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>image of the scattering matrix through the photonic homomorphism.</p> Source code in <code>qoptcraft/evolution/photon_unitary.py</code> <pre><code>def photon_unitary(\n    scattering_matrix: NDArray,\n    photons: int,\n    method: Literal[\n        \"heisenberg\", \"hamiltonian\", \"permanent glynn\", \"permanent ryser\"\n    ] = \"permanent glynn\",\n) -&gt; NDArray:\n\"\"\"Unitary matrix of a linear interferometer with a number of photons as input.\n\n    Args:\n        scattering_matrix (NDArray): scattering matrix of a linear optical interferometer.\n        photons (int): number of photons.\n        method (str): method to calculate the multiphoton unitary. Options are 'heisenberg',\n            'hamiltonian', 'permanent glynn' or 'permanent ryser'. Default is 'permanent glynn'.\n\n    Returns:\n        NDArray: image of the scattering matrix through the photonic homomorphism.\n    \"\"\"\n    if method.split()[0] == \"permanent\":\n        return photon_unitary_permanent(scattering_matrix, photons, method=method.split()[1])\n    if method == \"heisenberg\":\n        return photon_unitary_heisenberg(scattering_matrix, photons)\n    if method == \"hamiltonian\":\n        return photon_unitary_hamiltonian(scattering_matrix, photons)\n    raise ValueError(\n        \"Options for method are 'heisenberg', 'hamiltonian', 'permanent glynn' or 'permanent ryser'\"\n    )\n</code></pre>"},{"location":"reference/evolution/photon_unitary/#qoptcraft.evolution.photon_unitary.photon_unitary_hamiltonian","title":"<code>photon_unitary_hamiltonian(scattering_matrix, photons)</code>","text":"<p>\"Unitary matrix of a linear interferometer with a number of photons as input. Calculated by evolving the hamiltonian of the interferometer.</p> <p>Parameters:</p> Name Type Description Default <code>scattering_matrix</code> <code>NDArray</code> <p>scattering matrix of a linear optical interferometer.</p> required <code>photons</code> <code>int</code> <p>number of photons.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>image of the scattering matrix through the photonic homomorphism.</p> Source code in <code>qoptcraft/evolution/photon_unitary.py</code> <pre><code>def photon_unitary_hamiltonian(scattering_matrix: NDArray, photons: int) -&gt; NDArray:\n\"\"\" \"Unitary matrix of a linear interferometer with a number of photons as input.\n    Calculated by evolving the hamiltonian of the interferometer.\n\n    Args:\n        scattering_matrix (NDArray): scattering matrix of a linear optical interferometer.\n        photons (int): number of photons.\n\n    Returns:\n        NDArray: image of the scattering matrix through the photonic homomorphism.\n    \"\"\"\n    S_hamiltonian = log_matrix(scattering_matrix, method=\"schur\")  # ? Best method??\n    U_hamiltonian = photon_hamiltonian(S_hamiltonian, photons)\n    return sp.linalg.expm(U_hamiltonian)\n</code></pre>"},{"location":"reference/evolution/photon_unitary/#qoptcraft.evolution.photon_unitary.photon_unitary_heisenberg","title":"<code>photon_unitary_heisenberg(scattering_matrix, photons)</code>","text":"<p>Standard evolution given by quantum mechanics.</p> <p>Parameters:</p> Name Type Description Default <code>scattering_matrix</code> <code>NDArray</code> <p>scattering matrix of a linear optical interferometer.</p> required <code>photons</code> <code>int</code> <p>number of photons.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>image of the scattering matrix through the photonic homomorphism.</p> Source code in <code>qoptcraft/evolution/photon_unitary.py</code> <pre><code>def photon_unitary_heisenberg(scattering_matrix: NDArray, photons: int) -&gt; NDArray:\n\"\"\"Standard evolution given by quantum mechanics.\n\n    Args:\n        scattering_matrix (NDArray): scattering matrix of a linear optical interferometer.\n        photons (int): number of photons.\n\n    Returns:\n        NDArray: image of the scattering matrix through the photonic homomorphism.\n    \"\"\"\n    modes = scattering_matrix.shape[0]\n    dim = hilbert_dim(modes, photons)\n    unitary = np.zeros((dim, dim), dtype=np.complex64)\n    photon_basis = get_photon_basis(modes, photons)\n\n    for col, fock_in in enumerate(photon_basis):\n        unitary[:, col] = fock_evolution_heisenberg(scattering_matrix, fock_in).state_in_basis()\n    return unitary\n</code></pre>"},{"location":"reference/evolution/photon_unitary/#qoptcraft.evolution.photon_unitary.photon_unitary_permanent","title":"<code>photon_unitary_permanent(scattering_matrix, photons, method='glynn')</code>","text":"<p>Unitary matrix of a linear interferometer with a number of photons as input. Calculated using permanents:</p> <p> = Per(U_ST) / sqrt(s1! ...sm! t1! ... tm!) <p>Parameters:</p> Name Type Description Default <code>scattering_matrix</code> <code>NDArray</code> <p>scattering matrix of a linear optical interferometer.</p> required <code>photons</code> <code>int</code> <p>number of photons.</p> required <code>method</code> <code>str</code> <p>method to calculate the permanent. Options are 'glynn' and 'ryser'. Defaults to 'glynn'.</p> <code>'glynn'</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>image of the scattering matrix through the photonic homomorphism.</p> Source code in <code>qoptcraft/evolution/photon_unitary.py</code> <pre><code>def photon_unitary_permanent(\n    scattering_matrix: NDArray, photons: int, method: str = \"glynn\"\n) -&gt; NDArray:\n\"\"\"Unitary matrix of a linear interferometer with a number of photons as input.\n    Calculated using permanents:\n\n    &lt;S|phi(U)|T&gt; = Per(U_ST) / sqrt(s1! ...sm! t1! ... tm!)\n\n    Args:\n        scattering_matrix (NDArray): scattering matrix of a linear optical interferometer.\n        photons (int): number of photons.\n        method (str): method to calculate the permanent. Options are 'glynn' and 'ryser'.\n            Defaults to 'glynn'.\n\n    Returns:\n        NDArray: image of the scattering matrix through the photonic homomorphism.\n    \"\"\"\n    modes = scattering_matrix.shape[0]\n    dim = hilbert_dim(modes, photons)\n    unitary = np.empty((dim, dim), dtype=np.complex128)\n    photon_basis = get_photon_basis(modes, photons)\n\n    for col, fock_in in enumerate(photon_basis):\n        unitary[:, col] = fock_evolution_permanent(scattering_matrix, fock_in, method, photon_basis)\n    return unitary\n</code></pre>"},{"location":"reference/invariant/","title":"invariant","text":""},{"location":"reference/invariant/#qoptcraft.invariant","title":"<code>qoptcraft.invariant</code>","text":""},{"location":"reference/invariant/forbidden_transition/","title":"forbidden_transition","text":""},{"location":"reference/invariant/forbidden_transition/#qoptcraft.invariant.forbidden_transition","title":"<code>qoptcraft.invariant.forbidden_transition</code>","text":"<p>Check if a transition violates the necessary criterion of the invariant conservation.</p>"},{"location":"reference/invariant/forbidden_transition/#qoptcraft.invariant.forbidden_transition.forbidden_transition","title":"<code>forbidden_transition(state_in, state_out, method='basis', print_invariant=True)</code>","text":"<p>Check if we cannot transition from an input state to an output state through an optical network.</p> <p>Parameters:</p> Name Type Description Default <code>state_in</code> <code>State</code> <p>input state of the optical circuit.</p> required <code>state_out</code> <code>State</code> <p>desired output state of the optical circuit.</p> required <code>method</code> <code>str</code> <p>method to calculate the invariant. Options are 'reduced', 'full', 'basis'. Default is 'basis'.</p> <code>'basis'</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the transition is forbidden. True if it is not.</p> Source code in <code>qoptcraft/invariant/forbidden_transition.py</code> <pre><code>def forbidden_transition(\n    state_in: State,\n    state_out: State,\n    method: Literal[\"reduced\", \"no basis\", \"basis\"] = \"basis\",\n    print_invariant: bool = True,\n) -&gt; bool:\n\"\"\"Check if we cannot transition from an input state to an output state\n    through an optical network.\n\n    Args:\n        state_in (State): input state of the optical circuit.\n        state_out (State): desired output state of the optical circuit.\n        method (str): method to calculate the invariant. Options are 'reduced',\n            'full', 'basis'. Default is 'basis'.\n\n    Returns:\n        bool: True if the transition is forbidden. True if it is not.\n    \"\"\"\n    if method == \"basis\":\n        return forbidden_transition_basis(state_in, state_out, print_invariant=print_invariant)\n    if not isinstance(state_in, PureState) or not isinstance(state_out, PureState):\n        raise ValueError(\"Non pure states only accept method basis.\")\n    if method == \"reduced\":\n        return forbidden_transition_reduced(state_in, state_out, print_invariant=print_invariant)\n    if method == \"no basis\":\n        return forbidden_transition_no_basis(state_in, state_out, print_invariant=print_invariant)\n    raise ValueError(\"Options for 'method' are 'reduced', 'no basis' or 'basis'.\")\n</code></pre>"},{"location":"reference/invariant/forbidden_transition/#qoptcraft.invariant.forbidden_transition.forbidden_transition_basis","title":"<code>forbidden_transition_basis(state_in, state_out, print_invariant=True)</code>","text":"<p>Check if we cannot transition from an input state to an output state through an optical network.</p> Note <p>This criterion is necessary, but not sufficient. Even if the transition doesn't violate the criterion (<code>True</code> output), a unitary may not exist.</p> <p>Parameters:</p> Name Type Description Default <code>state_in</code> <code>State</code> <p>input state of the optical circuit.</p> required <code>state_out</code> <code>State</code> <p>desired output state of the optical circuit.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the transition is forbidden. True if it is not.</p> Source code in <code>qoptcraft/invariant/forbidden_transition.py</code> <pre><code>def forbidden_transition_basis(\n    state_in: State, state_out: State, print_invariant: bool = True\n) -&gt; bool:\n\"\"\"Check if we cannot transition from an input state to an output state\n    through an optical network.\n\n    Note:\n        This criterion is necessary, but not sufficient. Even if the transition\n        doesn't violate the criterion (`True` output), a unitary may not exist.\n\n    Args:\n        state_in (State): input state of the optical circuit.\n        state_out (State): desired output state of the optical circuit.\n\n    Returns:\n        bool: True if the transition is forbidden. True if it is not.\n    \"\"\"\n    assert state_in.photons == state_out.photons, \"Number of photons don't coincide.\"\n    assert state_in.modes == state_out.modes, \"Number of modes don't coincide.\"\n\n    in_invariant = photon_invariant_basis(state_in)\n    out_invariant = photon_invariant_basis(state_out)\n\n    if print_invariant:\n        print(f\"In invariant = {in_invariant:.7f} \\t Out invariant = {out_invariant:.7f}\")\n    return not np.isclose(in_invariant, out_invariant)\n</code></pre>"},{"location":"reference/invariant/forbidden_transition/#qoptcraft.invariant.forbidden_transition.forbidden_transition_no_basis","title":"<code>forbidden_transition_no_basis(state_in, state_out, print_invariant=True)</code>","text":"<p>Check if we cannot transition from an input state to an output state through an optical network. Calculations are done without a basis of the Hilbert space, so they are faster and more efficient.</p> Note <p>This criterion is necessary, but not sufficient. Even if the transition doesn't violate the criterion (<code>True</code> output), a unitary may not exist.</p> <p>Parameters:</p> Name Type Description Default <code>state_in</code> <code>State</code> <p>input state of the optical circuit.</p> required <code>state_out</code> <code>State</code> <p>desired output state of the optical circuit.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the transition is forbidden. True if it is not.</p> Source code in <code>qoptcraft/invariant/forbidden_transition.py</code> <pre><code>def forbidden_transition_no_basis(\n    state_in: PureState, state_out: PureState, print_invariant: bool = True\n) -&gt; bool:\n\"\"\"Check if we cannot transition from an input state to an output state\n    through an optical network. Calculations are done without a basis of the Hilbert space,\n    so they are faster and more efficient.\n\n    Note:\n        This criterion is necessary, but not sufficient. Even if the transition\n        doesn't violate the criterion (`True` output), a unitary may not exist.\n\n    Args:\n        state_in (State): input state of the optical circuit.\n        state_out (State): desired output state of the optical circuit.\n\n    Returns:\n        bool: True if the transition is forbidden. True if it is not.\n    \"\"\"\n    assert state_in.photons == state_out.photons, \"Number of photons don't coincide.\"\n    assert state_in.modes == state_out.modes, \"Number of modes don't coincide.\"\n\n    in_invariant = photon_invariant_no_basis(state_in)\n    out_invariant = photon_invariant_no_basis(state_out)\n    if print_invariant:\n        print(f\"In full invariant = {in_invariant:.7f} \\t Out full invariant = {out_invariant:.7f}\")\n    return not np.isclose(in_invariant, out_invariant)\n</code></pre>"},{"location":"reference/invariant/forbidden_transition/#qoptcraft.invariant.forbidden_transition.forbidden_transition_reduced","title":"<code>forbidden_transition_reduced(state_in, state_out, print_invariant=True)</code>","text":"<p>Check if we cannot transition from an input state to an output state through an optical network. Calculations are done with the reduced invariant, which is faster and more efficient.</p> Note <p>This criterion is necessary, but not sufficient. Even if the transition doesn't violate the criterion (<code>True</code> output), a unitary may not exist.</p> <p>Parameters:</p> Name Type Description Default <code>state_in</code> <code>State</code> <p>input state of the optical circuit.</p> required <code>state_out</code> <code>State</code> <p>desired output state of the optical circuit.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the transition is forbidden. True if it is not.</p> Source code in <code>qoptcraft/invariant/forbidden_transition.py</code> <pre><code>def forbidden_transition_reduced(\n    state_in: PureState, state_out: PureState, print_invariant: bool = True\n) -&gt; bool:\n\"\"\"Check if we cannot transition from an input state to an output state\n    through an optical network. Calculations are done with the reduced invariant,\n    which is faster and more efficient.\n\n    Note:\n        This criterion is necessary, but not sufficient. Even if the transition\n        doesn't violate the criterion (`True` output), a unitary may not exist.\n\n    Args:\n        state_in (State): input state of the optical circuit.\n        state_out (State): desired output state of the optical circuit.\n\n    Returns:\n        bool: True if the transition is forbidden. True if it is not.\n    \"\"\"\n    assert state_in.photons == state_out.photons, \"Number of photons don't coincide.\"\n    assert state_in.modes == state_out.modes, \"Number of modes don't coincide.\"\n\n    in_invariant = photon_invariant_reduced(state_in)\n    out_invariant = photon_invariant_reduced(state_out)\n\n    if print_invariant:\n        print(\n            f\"In reduced invariant = {in_invariant:.7f}\"\n            f\"\\t Out reduced invariant = {out_invariant:.7f}\"\n        )\n    return not np.isclose(in_invariant, out_invariant)\n</code></pre>"},{"location":"reference/invariant/invariant/","title":"invariant","text":""},{"location":"reference/invariant/invariant/#qoptcraft.invariant.invariant","title":"<code>qoptcraft.invariant.invariant</code>","text":"<p>Module docstrings.</p>"},{"location":"reference/invariant/invariant/#qoptcraft.invariant.invariant.photon_invariant","title":"<code>photon_invariant(state, method='basis')</code>","text":"<p>Photonic invariant for a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>a photonic quantum state.</p> required <code>method</code> <code>str</code> <p>method to calculate the invariant. Options are 'reduced', 'no basis', 'basis'. Default is 'basis'.</p> <code>'basis'</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>invariant.</p> Source code in <code>qoptcraft/invariant/invariant.py</code> <pre><code>def photon_invariant(state: State, method: str = \"basis\") -&gt; float:\n\"\"\"Photonic invariant for a given state.\n\n    Args:\n        state (State): a photonic quantum state.\n        method (str): method to calculate the invariant. Options are 'reduced',\n            'no basis', 'basis'. Default is 'basis'.\n\n    Returns:\n        float: invariant.\n    \"\"\"\n    if method == \"basis\":\n        return photon_invariant_basis(state)\n    if not isinstance(state, PureState):\n        raise ValueError(\"Non pure states only accept method basis.\")\n    if method == \"reduced\":\n        return photon_invariant_reduced(state)\n    if method == \"no basis\":\n        return photon_invariant_no_basis(state)\n    raise ValueError(\"Options for 'method' are 'reduced', 'no basis' or 'basis'.\")\n</code></pre>"},{"location":"reference/invariant/invariant/#qoptcraft.invariant.invariant.photon_invariant_basis","title":"<code>photon_invariant_basis(state)</code>","text":"<p>Calculate the photonic invariant for a given state.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>a photonic quantum state.</p> required <p>Returns:</p> Type Description <code>tuple[float, float]</code> <p>tuple[float, float]: tangent invariant.</p> Source code in <code>qoptcraft/invariant/invariant.py</code> <pre><code>def photon_invariant_basis(state: State) -&gt; tuple[float, float]:\n\"\"\"Calculate the photonic invariant for a given state.\n\n    Args:\n        state (State): a photonic quantum state.\n\n    Returns:\n        tuple[float, float]: tangent invariant.\n    \"\"\"\n    basis_img_algebra = get_algebra_basis(state.modes, state.photons)[1]\n    coefs = []\n    for basis_matrix in gram_schmidt_generator(basis_img_algebra):\n        coefs.append(hs_scalar_product(1j * state.density_matrix, basis_matrix))\n    tangent_invariant = sum(np.abs(coefs) ** 2)\n    return tangent_invariant\n</code></pre>"},{"location":"reference/invariant/invariant/#qoptcraft.invariant.invariant.photon_invariant_no_basis","title":"<code>photon_invariant_no_basis(state)</code>","text":"<p>Calculate the photonic invariant for a given state without using the Hilbert space basis.</p> Note <p>Calculations without using the basis are much faster and memory efficient.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>a photonic quantum state.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>invariant.</p> Source code in <code>qoptcraft/invariant/invariant.py</code> <pre><code>def photon_invariant_no_basis(state: PureState) -&gt; float:\n\"\"\"Calculate the photonic invariant for a given state without using the\n    Hilbert space basis.\n\n    Note:\n        Calculations without using the basis are much faster and memory efficient.\n\n    Args:\n        state (State): a photonic quantum state.\n\n    Returns:\n        float: invariant.\n    \"\"\"\n    invariant = photon_invariant_reduced(state)\n    modes = state.modes\n    photons = state.photons\n    C1 = (modes * photons + 1) * fact(modes) * fact(photons) / fact(modes + photons)\n    C2 = 2 * fact(modes + 1) * fact(photons - 1) / fact(modes + photons)\n    if np.isnan(C1):\n        C1 = 0\n    if np.isnan(C2):\n        C2 = 0\n    return C1 + C2 * invariant\n</code></pre>"},{"location":"reference/invariant/invariant/#qoptcraft.invariant.invariant.photon_invariant_reduced","title":"<code>photon_invariant_reduced(state)</code>","text":"<p>Calculate the reduced photonic invariant for a given state without using the Hilbert space basis.</p> Note <p>Calculations without using the basis are much faster and memory efficient.</p> <p>Parameters:</p> Name Type Description Default <code>state</code> <code>State</code> <p>a photonic quantum state.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>invariant.</p> Source code in <code>qoptcraft/invariant/invariant.py</code> <pre><code>def photon_invariant_reduced(state: PureState) -&gt; float:\n\"\"\"Calculate the reduced photonic invariant for a given state without using the\n    Hilbert space basis.\n\n    Note:\n        Calculations without using the basis are much faster and memory efficient.\n\n    Args:\n        state (State): a photonic quantum state.\n\n    Returns:\n        float: invariant.\n    \"\"\"\n    modes = state.modes\n    invariant = 0\n    for mode_1 in range(modes):\n        for mode_2 in range(mode_1 + 1, modes):\n            invariant += state.exp_photons(mode_1, mode_2) * state.exp_photons(mode_2, mode_1)\n            invariant -= state.exp_photons(mode_1, mode_1) * state.exp_photons(mode_2, mode_2)\n    return invariant.real\n</code></pre>"},{"location":"reference/math/","title":"math","text":""},{"location":"reference/math/#qoptcraft.math","title":"<code>qoptcraft.math</code>","text":""},{"location":"reference/math/gram_schmidt/","title":"gram_schmidt","text":""},{"location":"reference/math/gram_schmidt/#qoptcraft.math.gram_schmidt","title":"<code>qoptcraft.math.gram_schmidt</code>","text":"<p>Stable Gram-Schmidt algorithm.</p>"},{"location":"reference/math/gram_schmidt/#qoptcraft.math.gram_schmidt.gram_schmidt","title":"<code>gram_schmidt(basis)</code>","text":"<p>Gram-Schmidt algorithm to orthonormalize a basis.</p> Note <p>It turns out that the normal Gram-Schmidt algorithm suffers from numerical instability: Round-off errors can accumulate and destroy orthogonality of the resulting vectors. We introduce the modified Gram-Schmidt procedure to help remedy this issue.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>list[spmatrix]</code> <p>basis to orthonormalize.</p> required <p>Returns:</p> Type Description <code>list[spmatrix] | list[NDArray]</code> <p>list[spmatrix]: orthonormalized basis.</p> References <p>Algorithm can be found in https://www.math.uci.edu/~ttrogdon/105A/html/Lecture23.html</p> Source code in <code>qoptcraft/math/gram_schmidt.py</code> <pre><code>def gram_schmidt(basis: list[spmatrix] | list[NDArray]) -&gt; list[spmatrix] | list[NDArray]:\n\"\"\"Gram-Schmidt algorithm to orthonormalize a basis.\n\n    Note:\n        It turns out that the normal Gram-Schmidt algorithm suffers from\n        numerical instability: Round-off errors can accumulate and destroy\n        orthogonality of the resulting vectors. We introduce the modified\n        Gram-Schmidt procedure to help remedy this issue.\n\n    Args:\n        basis (list[spmatrix]): basis to orthonormalize.\n\n    Returns:\n        list[spmatrix]: orthonormalized basis.\n\n    References:\n        Algorithm can be found in https://www.math.uci.edu/~ttrogdon/105A/html/Lecture23.html\n    \"\"\"\n    dim = len(basis)\n    orth_basis = []\n\n    for j in range(dim):\n        orth_basis.append(basis[j] / hs_norm(basis[j]))\n        for k in range(j + 1, dim):\n            basis[k] = basis[k] - hs_scalar_product(orth_basis[j], basis[k]) * orth_basis[j]\n    return orth_basis\n</code></pre>"},{"location":"reference/math/gram_schmidt/#qoptcraft.math.gram_schmidt.gram_schmidt_generator","title":"<code>gram_schmidt_generator(basis)</code>","text":"<p>Gram-Schmidt algorithm to orthonormalize a basis.</p> Note <p>It turns out that the normal Gram-Schmidt algorithm suffers from numerical instability: Round-off errors can accumulate and destroy orthogonality of the resulting vectors. We introduce the modified Gram-Schmidt procedure to help remedy this issue.</p> <p>Parameters:</p> Name Type Description Default <code>basis</code> <code>list[spmatrix]</code> <p>basis to orthonormalize.</p> required <p>Yields:</p> Type Description <code>list[spmatrix] | list[NDArray]</code> <p>NDArray or spmatrix: orthonormalized basis element.</p> References <p>Algorithm can be found in https://www.math.uci.edu/~ttrogdon/105A/html/Lecture23.html</p> Source code in <code>qoptcraft/math/gram_schmidt.py</code> <pre><code>def gram_schmidt_generator(basis: list[spmatrix] | list[NDArray]) -&gt; list[spmatrix] | list[NDArray]:\n\"\"\"Gram-Schmidt algorithm to orthonormalize a basis.\n\n    Note:\n        It turns out that the normal Gram-Schmidt algorithm suffers from\n        numerical instability: Round-off errors can accumulate and destroy\n        orthogonality of the resulting vectors. We introduce the modified\n        Gram-Schmidt procedure to help remedy this issue.\n\n    Args:\n        basis (list[spmatrix]): basis to orthonormalize.\n\n    Yields:\n        NDArray or spmatrix: orthonormalized basis element.\n\n    References:\n        Algorithm can be found in https://www.math.uci.edu/~ttrogdon/105A/html/Lecture23.html\n    \"\"\"\n    dim = len(basis)\n    orth_basis = []\n\n    for j in range(dim):\n        orth_basis.append(basis[j] / hs_norm(basis[j]))\n        yield orth_basis[j]\n        for k in range(j + 1, dim):\n            basis[k] = basis[k] - hs_scalar_product(orth_basis[j], basis[k]) * orth_basis[j]\n</code></pre>"},{"location":"reference/math/logarithms/","title":"logarithms","text":""},{"location":"reference/math/logarithms/#qoptcraft.math.logarithms","title":"<code>qoptcraft.math.logarithms</code>","text":"<p>Logarithms of matrices.</p> References <p>Algorithms can be found in     T.A. Loring, Numer. Linear Algebra Appl. 21 (6) (2014) 744-760.     https://arxiv.org/abs/1203.6151</p>"},{"location":"reference/math/logarithms/#qoptcraft.math.logarithms.log_matrix","title":"<code>log_matrix(matrix, method='diagonalization')</code>","text":"<p>Logarithm of matrix via symmetrized diagonalization.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray</code> <p>square matrix.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>matrix logarithm.</p> Source code in <code>qoptcraft/math/logarithms.py</code> <pre><code>def log_matrix(\n    matrix: NDArray,\n    method: Literal[\n        \"diagonalization\", \"symmetrized\", \"schur\", \"polar\", \"newton\"\n    ] = \"diagonalization\",\n) -&gt; NDArray:\n\"\"\"Logarithm of matrix via symmetrized diagonalization.\n\n    Args:\n        matrix (NDArray): square matrix.\n\n    Returns:\n        NDArray: matrix logarithm.\n    \"\"\"\n    if method == \"diagonalization\":\n        return log_matrix_diag(matrix)\n    if method == \"symmetrized\":\n        return log_matrix_sym(matrix)\n    if method == \"schur\":\n        return log_matrix_schur(matrix)\n    if method == \"polar\":\n        return log_matrix_polar_schur(matrix)\n    if method == \"newton\":\n        return log_matrix_newton_schur(matrix)\n    raise ValueError(\n        \"Values for method are 'diagonalization', 'symmetrized', 'schur', 'polar' or 'newton'.\"\n    )\n</code></pre>"},{"location":"reference/math/logarithms/#qoptcraft.math.logarithms.log_matrix_diag","title":"<code>log_matrix_diag(matrix)</code>","text":"<p>Logarithm of matrix via symmetrized diagonalization.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray</code> <p>square matrix.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>matrix logarithm.</p> Source code in <code>qoptcraft/math/logarithms.py</code> <pre><code>def log_matrix_diag(matrix: NDArray) -&gt; NDArray:\n\"\"\"Logarithm of matrix via symmetrized diagonalization.\n\n    Args:\n        matrix (NDArray): square matrix.\n\n    Returns:\n        NDArray: matrix logarithm.\n    \"\"\"\n    eigenvalues, eigenvectors = np.linalg.eig(matrix)\n    diag = np.diag(eigenvalues / np.abs(eigenvalues))\n    log_matrix = eigenvectors @ logm(diag) @ inv(eigenvectors)\n    return (log_matrix + log_matrix.conj().T) / 2\n</code></pre>"},{"location":"reference/math/logarithms/#qoptcraft.math.logarithms.log_matrix_newton_schur","title":"<code>log_matrix_newton_schur(matrix)</code>","text":"<p>Logarithm of matrix using Schur's decomposition. Used to diagonalize nearly unitary matrices.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray</code> <p>square matrix.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>matrix logarithm.</p> Source code in <code>qoptcraft/math/logarithms.py</code> <pre><code>def log_matrix_newton_schur(matrix: NDArray) -&gt; NDArray:\n\"\"\"Logarithm of matrix using Schur's decomposition. Used to diagonalize\n    nearly unitary matrices.\n\n    Args:\n        matrix (NDArray): square matrix.\n\n    Returns:\n        NDArray: matrix logarithm.\n    \"\"\"\n    V1 = (matrix + inv(matrix).conj().T) / 2\n    V = (V1 + inv(V1).conj().T) / 2\n    U, Q = schur(V)\n    diag = np.diag(np.diag(U) / np.abs(np.diag(U)))\n    return Q @ logm(diag) @ Q.conj().T\n</code></pre>"},{"location":"reference/math/logarithms/#qoptcraft.math.logarithms.log_matrix_polar_schur","title":"<code>log_matrix_polar_schur(matrix)</code>","text":"<p>Logarithm of matrix using Polar and Schur's decomposition. Used to diagonalize nearly unitary matrices.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray</code> <p>square matrix.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>matrix logarithm.</p> Source code in <code>qoptcraft/math/logarithms.py</code> <pre><code>def log_matrix_polar_schur(matrix: NDArray) -&gt; NDArray:\n\"\"\"Logarithm of matrix using Polar and Schur's decomposition. Used to\n    diagonalize nearly unitary matrices.\n\n    Args:\n        matrix (NDArray): square matrix.\n\n    Returns:\n        NDArray: matrix logarithm.\n    \"\"\"\n    V = matrix @ inv(sqrtm(matrix.conj().T @ matrix))  # TODO: use SVD\n    U, Q = schur(V)\n    diag = np.diag(np.diag(U) / np.abs(np.diag(U)))\n    return Q @ logm(diag) @ Q.conj().T\n</code></pre>"},{"location":"reference/math/logarithms/#qoptcraft.math.logarithms.log_matrix_schur","title":"<code>log_matrix_schur(matrix)</code>","text":"<p>Logarithm of matrix using Schur's decomposition. Used to diagonalize nearly unitary matrices.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray</code> <p>square matrix.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>matrix logarithm.</p> Source code in <code>qoptcraft/math/logarithms.py</code> <pre><code>def log_matrix_schur(matrix: NDArray) -&gt; NDArray:\n\"\"\"Logarithm of matrix using Schur's decomposition. Used to diagonalize\n    nearly unitary matrices.\n\n    Args:\n        matrix (NDArray): square matrix.\n\n    Returns:\n        NDArray: matrix logarithm.\n    \"\"\"\n    U, Q = schur(matrix)\n    diag = np.diag(np.diag(U) / np.abs(np.diag(U)))\n    return Q @ logm(diag) @ Q.conj().T\n</code></pre>"},{"location":"reference/math/logarithms/#qoptcraft.math.logarithms.log_matrix_sym","title":"<code>log_matrix_sym(matrix)</code>","text":"<p>Symmetrized logarithm of matrix.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray</code> <p>square matrix.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>matrix logarithm.</p> Source code in <code>qoptcraft/math/logarithms.py</code> <pre><code>def log_matrix_sym(matrix: NDArray) -&gt; NDArray:\n\"\"\"Symmetrized logarithm of matrix.\n\n    Args:\n        matrix (NDArray): square matrix.\n\n    Returns:\n        NDArray: matrix logarithm.\n    \"\"\"\n    log_matrix = logm(matrix)\n    return (log_matrix + log_matrix.conj().T) / 2\n</code></pre>"},{"location":"reference/math/mat_inner_product/","title":"mat_inner_product","text":""},{"location":"reference/math/mat_inner_product/#qoptcraft.math.mat_inner_product","title":"<code>qoptcraft.math.mat_inner_product</code>","text":"<p>Matrix inner product and norm.</p>"},{"location":"reference/math/mat_inner_product/#qoptcraft.math.mat_inner_product.hs_inner_product","title":"<code>hs_inner_product(matrix_1, matrix_2)</code>","text":"<p>Hilbert-Schmidt product of two matrices.</p> <p>Parameters:</p> Name Type Description Default <code>matrix_1</code> <code>Matrix</code> <p>first matrix</p> required <code>matrix_2</code> <code>Matrix</code> <p>second matrix</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Matrix type is not array or scipy sparse.</p> <p>Returns:</p> Name Type Description <code>Number</code> <code>Number</code> <p>scalar value of the product.</p> Source code in <code>qoptcraft/math/mat_inner_product.py</code> <pre><code>def hs_inner_product(matrix_1: Matrix, matrix_2: Matrix) -&gt; Number:\n\"\"\"Hilbert-Schmidt product of two matrices.\n\n    Args:\n        matrix_1 (Matrix): first matrix\n        matrix_2 (Matrix): second matrix\n\n    Raises:\n        ValueError: Matrix type is not array or scipy sparse.\n\n    Returns:\n        Number: scalar value of the product.\n    \"\"\"\n    result = (matrix_1.conj().T @ matrix_2).trace()\n    # assert not np.isnan(result), \"Matrix inner product is not a number.\"\n    return result\n</code></pre>"},{"location":"reference/math/mat_inner_product/#qoptcraft.math.mat_inner_product.hs_norm","title":"<code>hs_norm(matrix)</code>","text":"<p>Hilbert-Schmidt norm of a matrix</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Matrix</code> <p>a matrix.</p> required <p>Returns:</p> Name Type Description <code>Number</code> <code>float</code> <p>the norm.</p> Source code in <code>qoptcraft/math/mat_inner_product.py</code> <pre><code>def hs_norm(matrix: Matrix) -&gt; float:\n\"\"\"Hilbert-Schmidt norm of a matrix\n\n    Args:\n        matrix (Matrix): a matrix.\n\n    Returns:\n        Number: the norm.\n    \"\"\"\n    return np.sqrt(np.real(hs_inner_product(matrix, matrix)))\n</code></pre>"},{"location":"reference/math/mat_inner_product/#qoptcraft.math.mat_inner_product.hs_scalar_product","title":"<code>hs_scalar_product(matrix_1, matrix_2)</code>","text":"<p>Hilbert-Schmidt product of two matrices.</p> <p>Parameters:</p> Name Type Description Default <code>matrix_1</code> <code>Matrix</code> <p>first matrix</p> required <code>matrix_2</code> <code>Matrix</code> <p>second matrix</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Matrix type is not array or scipy sparse.</p> <p>Returns:</p> Name Type Description <code>Number</code> <code>Number</code> <p>scalar value of the product.</p> Source code in <code>qoptcraft/math/mat_inner_product.py</code> <pre><code>def hs_scalar_product(matrix_1: Matrix, matrix_2: Matrix) -&gt; Number:\n\"\"\"Hilbert-Schmidt product of two matrices.\n\n    Args:\n        matrix_1 (Matrix): first matrix\n        matrix_2 (Matrix): second matrix\n\n    Raises:\n        ValueError: Matrix type is not array or scipy sparse.\n\n    Returns:\n        Number: scalar value of the product.\n    \"\"\"\n    result = 0.5 * (matrix_1.conj().T @ matrix_2 + matrix_2.conj().T @ matrix_1).trace()\n    # assert not np.isnan(result), \"Matrix inner product is not a number.\"\n    return result\n</code></pre>"},{"location":"reference/math/permanent/","title":"permanent","text":""},{"location":"reference/math/permanent/#qoptcraft.math.permanent","title":"<code>qoptcraft.math.permanent</code>","text":""},{"location":"reference/math/permanent/#qoptcraft.math.permanent.permanent","title":"<code>permanent(matrix, method='glynn')</code>","text":"<p>Returns the permanent of a matrix using the Ryser formula in Gray ordering.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray</code> <p>A square matrix</p> required <code>method</code> <code>str</code> <p>method to calculate the permanent. Options are 'glynn' and 'ryser'. Defaults to 'glynn'.</p> <code>'glynn'</code> <p>Returns:</p> Name Type Description <code>Number</code> <code>Number</code> <p>the permanent of the matrix</p> Source code in <code>qoptcraft/math/permanent.py</code> <pre><code>def permanent(matrix: NDArray, method: Literal[\"glynn\", \"ryser\"] = \"glynn\") -&gt; Number:\n\"\"\"Returns the permanent of a matrix using the Ryser formula in Gray ordering.\n\n    Args:\n        matrix (NDArray): A square matrix\n        method (str): method to calculate the permanent. Options are 'glynn' and 'ryser'.\n            Defaults to 'glynn'.\n\n    Returns:\n        Number: the permanent of the matrix\n    \"\"\"\n    if method == \"glynn\":\n        return _permanent_glynn(matrix)\n    if method == \"ryser\":\n        return _permanent_ryser(matrix)\n    raise ValueError(\"Supported options for the permanent are 'glynn' and 'ryser'.\")\n</code></pre>"},{"location":"reference/operators/","title":"operators","text":""},{"location":"reference/operators/#qoptcraft.operators","title":"<code>qoptcraft.operators</code>","text":""},{"location":"reference/operators/adjoint/","title":"adjoint","text":""},{"location":"reference/operators/adjoint/#qoptcraft.operators.adjoint","title":"<code>qoptcraft.operators.adjoint</code>","text":""},{"location":"reference/operators/adjoint/#qoptcraft.operators.adjoint.adjoint_evol","title":"<code>adjoint_evol(hamiltonian, unitary)</code>","text":"<p>Compute the Heisenberg evolution of a hamiltonian. This is done via the adjoint action of the unitary group on the algebra of hermitian matrices.</p> <p>Parameters:</p> Name Type Description Default <code>hamiltonian</code> <code>NDArray</code> <p>matrix of the hamiltonian.</p> required <code>unitary</code> <code>NDArray</code> <p>matrix of the unitary.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>evolved hamiltonian.</p> Source code in <code>qoptcraft/operators/adjoint.py</code> <pre><code>def adjoint_evol(hamiltonian: NDArray, unitary: NDArray) -&gt; NDArray:\n\"\"\"Compute the Heisenberg evolution of a hamiltonian.\n    This is done via the adjoint action of the unitary group\n    on the algebra of hermitian matrices.\n\n    Args:\n        hamiltonian (NDArray): matrix of the hamiltonian.\n        unitary (NDArray): matrix of the unitary.\n\n    Returns:\n        NDArray: evolved hamiltonian.\n    \"\"\"\n    return unitary @ hamiltonian @ unitary.conj().T\n</code></pre>"},{"location":"reference/operators/haar_random_unitary/","title":"haar_random_unitary","text":""},{"location":"reference/operators/haar_random_unitary/#qoptcraft.operators.haar_random_unitary","title":"<code>qoptcraft.operators.haar_random_unitary</code>","text":"<p>Random haar uniform unitary.</p>"},{"location":"reference/operators/haar_random_unitary/#qoptcraft.operators.haar_random_unitary.haar_random_unitary","title":"<code>haar_random_unitary(dim, seed=None)</code>","text":"<p>Create a random unitary matrix distributed with Haar measure.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>the dimension of the unitary matrix.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the haar uniform random unitary.</p> References <p>The algorithm can be found in Francesco Mezzadri, \"How to generate random matrices from the classical compact groups\" arXiv, 2007. https://arxiv.org/abs/math-ph/0609050</p> Source code in <code>qoptcraft/operators/haar_random_unitary.py</code> <pre><code>def haar_random_unitary(dim: int, seed: int = None) -&gt; NDArray:\n\"\"\"Create a random unitary matrix distributed with Haar measure.\n\n    Args:\n        dim (int): the dimension of the unitary matrix.\n\n    Returns:\n        NDArray: the haar uniform random unitary.\n\n    References:\n        The algorithm can be found in\n        Francesco Mezzadri, \"How to generate random matrices from the classical\n        compact groups\" arXiv, 2007. https://arxiv.org/abs/math-ph/0609050\n    \"\"\"\n    rng = np.random.default_rng() if seed is None else np.random.default_rng(seed)\n    Z = rng.normal(0, 1, dim * dim).reshape(dim, dim)\n    Z = (Z + 1j * rng.normal(0, 1, dim * dim).reshape(dim, dim)) / np.sqrt(2.0)\n    Q, R = sp.linalg.qr(Z)  # QR decomposition\n    D = np.diag(R)  # diag() outputs a 1-D array\n    \u039b = np.diag(D / np.absolute(D))  # diag() outputs a 2-D array again\n    return Q @ \u039b @ Q\n</code></pre>"},{"location":"reference/operators/ladder/","title":"ladder","text":""},{"location":"reference/operators/ladder/#qoptcraft.operators.ladder","title":"<code>qoptcraft.operators.ladder</code>","text":"<p>Creation and annihilation operators.</p>"},{"location":"reference/operators/ladder/#qoptcraft.operators.ladder.annihilation","title":"<code>annihilation(mode, fock)</code>","text":"<p>Annihilation operator acting on a specific mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>a quantum mode.</p> required <code>fock</code> <code>tuple[int, ...]</code> <p>fock basis state.</p> required <p>Returns:</p> Type Description <code>tuple[tuple[int, ...], float]</code> <p>tuple[int, ...], float: annihilated Fock state and its coefficient.</p> Source code in <code>qoptcraft/operators/ladder.py</code> <pre><code>def annihilation(mode: int, fock: tuple[int, ...]) -&gt; tuple[tuple[int, ...], float]:\n\"\"\"Annihilation operator acting on a specific mode.\n\n    Args:\n        mode (int): a quantum mode.\n        fock (tuple[int, ...]): fock basis state.\n\n    Returns:\n        tuple[int, ...], float: annihilated Fock state and its coefficient.\n    \"\"\"\n    photons = fock[mode]\n    coef = sqrt(photons)\n    fock = list(fock)\n    fock[mode] = photons - 1\n    return tuple(fock), coef\n</code></pre>"},{"location":"reference/operators/ladder/#qoptcraft.operators.ladder.creation","title":"<code>creation(mode, fock)</code>","text":"<p>Creation operator acting on a specific mode. Modifies state in-place.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>a quantum mode.</p> required <code>fock</code> <code>tuple[int, ...]</code> <p>fock basis state.</p> required <p>Returns:</p> Type Description <code>tuple[tuple[int, ...], float]</code> <p>tuple[int, ...], float: created Fock state and its coefficient.</p> Source code in <code>qoptcraft/operators/ladder.py</code> <pre><code>def creation(mode: int, fock: tuple[int]) -&gt; tuple[tuple[int, ...], float]:\n\"\"\"Creation operator acting on a specific mode. Modifies state in-place.\n\n    Args:\n        mode (int): a quantum mode.\n        fock (tuple[int, ...]): fock basis state.\n\n    Returns:\n        tuple[int, ...], float: created Fock state and its coefficient.\n    \"\"\"\n    photons = fock[mode]\n    coef = sqrt(photons + 1)\n    fock = list(fock)\n    fock[mode] = photons + 1\n    return tuple(fock), coef\n</code></pre>"},{"location":"reference/operators/qft/","title":"qft","text":""},{"location":"reference/operators/qft/#qoptcraft.operators.qft","title":"<code>qoptcraft.operators.qft</code>","text":""},{"location":"reference/operators/qft/#qoptcraft.operators.qft.qft","title":"<code>qft(dim)</code>","text":"<p>Matrix of the Quantum Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>dimension of the matrix.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>matrix of the transform.</p> Source code in <code>qoptcraft/operators/qft.py</code> <pre><code>def qft(dim: int) -&gt; NDArray:\n\"\"\"Matrix of the Quantum Fourier Transform.\n\n    Args:\n        dim (int): dimension of the matrix.\n\n    Returns:\n        NDArray: matrix of the transform.\n    \"\"\"\n    matrix = np.zeros((dim, dim), dtype=np.complex128)\n    frequency = 2j * math.pi / dim\n    for i in range(dim):\n        for j in range(dim):\n            matrix[i, j] = np.exp(frequency * i * j)\n    return matrix / np.sqrt(dim)\n</code></pre>"},{"location":"reference/operators/qft/#qoptcraft.operators.qft.qft_inv","title":"<code>qft_inv(dim)</code>","text":"<p>Matrix of the inverse of the Quantum Fourier Transform.</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>int</code> <p>dimension of the matrix.</p> required <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>matrix of the transform.</p> Source code in <code>qoptcraft/operators/qft.py</code> <pre><code>def qft_inv(dim: int) -&gt; NDArray:\n\"\"\"Matrix of the inverse of the Quantum Fourier Transform.\n\n    Args:\n        dim (int): dimension of the matrix.\n\n    Returns:\n        NDArray: matrix of the transform.\n    \"\"\"\n    matrix = np.zeros((dim, dim), dtype=np.complex128)\n    frequency = -2j * math.pi / dim\n    for i in range(dim):\n        for j in range(dim):\n            matrix[i, j] = np.exp(frequency * i * j)\n    return matrix / np.sqrt(dim)\n</code></pre>"},{"location":"reference/operators/quasiunitary/","title":"quasiunitary","text":""},{"location":"reference/operators/quasiunitary/#qoptcraft.operators.quasiunitary","title":"<code>qoptcraft.operators.quasiunitary</code>","text":""},{"location":"reference/operators/quasiunitary/#qoptcraft.operators.quasiunitary.random_quasiunitary","title":"<code>random_quasiunitary(shape, seed=None)</code>","text":"<p>Create a random quasiunitary matrix.</p> <p>Parameters:</p> Name Type Description Default <code>shape</code> <code>tuple</code> <p>dimensions of the matrix.</p> required <code>seed</code> <code>int</code> <p>seed to calculate the random unitary. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>matrix of the quasiunitary.</p> Source code in <code>qoptcraft/operators/quasiunitary.py</code> <pre><code>def random_quasiunitary(shape: tuple, seed: int | None = None) -&gt; NDArray:\n\"\"\"Create a random quasiunitary matrix.\n\n    Args:\n        shape (tuple): dimensions of the matrix.\n        seed (int, optional): seed to calculate the random unitary. Defaults to None.\n\n    Returns:\n        NDArray: matrix of the quasiunitary.\n    \"\"\"\n    dim_1, dim_2 = shape[0], shape[1]\n    rng = np.random.default_rng() if seed is None else np.random.default_rng(seed)\n    quasi_u = rng.standard_normal(dim_1 * dim_2).reshape(dim_1, dim_2)\n    quasi_u += 1j * rng.standard_normal(dim_1 * dim_2)\n    return quasi_u / np.sqrt(2)\n</code></pre>"},{"location":"reference/optical_elements/","title":"optical_elements","text":""},{"location":"reference/optical_elements/#qoptcraft.optical_elements","title":"<code>qoptcraft.optical_elements</code>","text":""},{"location":"reference/optical_elements/clemens_decomp/","title":"clemens_decomp","text":""},{"location":"reference/optical_elements/clemens_decomp/#qoptcraft.optical_elements.clemens_decomp","title":"<code>qoptcraft.optical_elements.clemens_decomp</code>","text":"<p>Decompose a unitary into beamsplitters following Clemens et al.</p>"},{"location":"reference/optical_elements/clemens_decomp/#qoptcraft.optical_elements.clemens_decomp.clemens_decomposition","title":"<code>clemens_decomposition(unitary)</code>","text":"<p>Given a unitary matrix calculates the Clemens et al. decompositon into beam splitters and phase shifters:</p> <p>D = L_n ... L_1 \u00b7 U \u00b7 R_1.inv ... R_n.inv  =&gt; =&gt; U = L_1.inv ... L_n.inv \u00b7 D \u00b7 R_n ... R_1</p> <p>Parameters:</p> Name Type Description Default <code>unitary</code> <code>NDArray</code> <p>unitary matrix to decompose.</p> required <p>Returns:</p> Type Description <code>tuple[list[NDArray], NDArray, list[NDArray]]</code> <p>list[NDArray]: list of matrices that decompose U in the order of the decomposition</p> References <p>[1] Clements et al., \"An Optimal Design for Universal Multiport     Interferometers\" arXiv, 2007. https://arxiv.org/pdf/1603.08788.pdf</p> Source code in <code>qoptcraft/optical_elements/clemens_decomp.py</code> <pre><code>def clemens_decomposition(unitary: NDArray) -&gt; tuple[list[NDArray], NDArray, list[NDArray]]:\n\"\"\"Given a unitary matrix calculates the Clemens et al. decompositon\n    into beam splitters and phase shifters:\n\n    D = L_n ... L_1 \u00b7 U \u00b7 R_1.inv ... R_n.inv  =&gt;\n    =&gt; U = L_1.inv ... L_n.inv \u00b7 D \u00b7 R_n ... R_1\n\n    Args:\n        unitary (NDArray): unitary matrix to decompose.\n\n    Returns:\n        list[NDArray]: list of matrices that decompose U in the order of the decomposition\n\n    References:\n        [1] Clements et al., \"An Optimal Design for Universal Multiport\n            Interferometers\" arXiv, 2007. https://arxiv.org/pdf/1603.08788.pdf\n    \"\"\"\n\n    assert unitary.shape[0] == unitary.shape[1], \"The matrix is not square\"\n    dim = unitary.shape[0]\n\n    right_list = []\n    left_list = []\n\n    for i in range(1, dim):\n        if (i % 2) == 1:\n            for j in range(i):\n                # substract 1 to all indices to match the paper with python arrays\n                row = dim - j - 1\n                col = i - j - 1\n                mode_1 = i - j - 1  # mode_1 must equal col\n                mode_2 = i - j\n\n                # We calculate the beamsplitter angles phi y theta\n                angle, shift = _solve_angles(unitary, mode_1, mode_2, row, col, is_odd=True)\n                R = beam_splitter(angle, shift, dim, mode_1, mode_2, convention=\"clemens\")\n                unitary = unitary @ R.conj().T\n                right_list.append(R)\n        else:\n            for j in range(1, i + 1):\n                # substract 1 to all indices to match the paper with python arrays\n                row = dim + j - i - 1\n                col = j - 1\n                mode_1 = dim + j - i - 2\n                mode_2 = dim + j - i - 1  # mode_2 must equal row\n\n                # We calculate the beamsplitter angles phi y theta\n                angle, shift = _solve_angles(unitary, mode_1, mode_2, row, col, is_odd=False)\n                left = beam_splitter(angle, shift, dim, mode_1, mode_2, convention=\"clemens\")\n                unitary = left @ unitary\n                left_list.append(left.conj().T)\n    diag = unitary\n\n    right_list.reverse()  # save as [R_n, ..., R_1]\n    # left_list = [L_1.inv, ... L_n.inv]\n\n    return left_list, diag, right_list\n</code></pre>"},{"location":"reference/optical_elements/optical_elements/","title":"optical_elements","text":""},{"location":"reference/optical_elements/optical_elements/#qoptcraft.optical_elements.optical_elements","title":"<code>qoptcraft.optical_elements.optical_elements</code>","text":"<p>Beamsplitters as defined in Clemens et al. and in Reck et al., respectively.</p>"},{"location":"reference/optical_elements/optical_elements/#qoptcraft.optical_elements.optical_elements.beam_splitter","title":"<code>beam_splitter(angle, shift, dim, mode_1, mode_2, convention='clemens')</code>","text":"<p>Create the beam splitter matrix with reflectivity cos(\u03b8) and phase shift \u03c6 acting on mode_1 and mode_2.</p> <p>Parameters:</p> Name Type Description Default <code>angle</code> <code>float</code> <p>reflectivity angle.</p> required <code>shift</code> <code>float</code> <p>phase shift angle.</p> required <code>dim</code> <code>int</code> <p>dimension of the circuit matrix.</p> required <code>mode_1</code> <code>int</code> <p>the first mode to which the beam splitter is applied. Starts at 0.</p> required <code>mode_2</code> <code>int</code> <p>the second mode to which the beam splitter is applied. Starts at 0.</p> required <code>convention</code> <code>str</code> <p>Beamsplitter definition according to different articles. Defaults to 'clemens'.</p> <code>'clemens'</code> <p>Returns:</p> Name Type Description <code>NDArray</code> <code>NDArray</code> <p>the matrix of the beam splitter</p> Source code in <code>qoptcraft/optical_elements/optical_elements.py</code> <pre><code>def beam_splitter(\n    angle: float, shift: float, dim: int, mode_1: int, mode_2: int, convention: str = \"clemens\"\n) -&gt; NDArray:\n\"\"\"Create the beam splitter matrix with reflectivity cos(\u03b8) and phase shift \u03c6\n    acting on mode_1 and mode_2.\n\n    Args:\n        angle (float): reflectivity angle.\n        shift (float): phase shift angle.\n        dim (int): dimension of the circuit matrix.\n        mode_1 (int): the first mode to which the beam splitter is applied. Starts at 0.\n        mode_2 (int): the second mode to which the beam splitter is applied. Starts at 0.\n        convention (str): Beamsplitter definition according to different articles.\n            Defaults to 'clemens'.\n\n    Returns:\n        NDArray: the matrix of the beam splitter\n    \"\"\"\n    if convention == \"clemens\":\n        return _beam_splitter_clemens(angle, shift, dim, mode_1, mode_2)\n    if convention == \"reck\":\n        return _beam_splitter_reck(angle, shift, dim, mode_1, mode_2)\n    if convention == \"chernikov\":\n        return _beam_splitter_chernikov(angle, shift, dim, mode_1, mode_2)\n    raise ValueError(\"Options for convention parameter are 'clemens', 'reck' or 'chernikov'.\")\n</code></pre>"},{"location":"reference/optical_elements/optical_elements/#qoptcraft.optical_elements.optical_elements.phase_shifter","title":"<code>phase_shifter(shift, dim, mode)</code>","text":"<p>Create a phase shifter of a certain angle acting on a mode.</p> <p>Parameters:</p> Name Type Description Default <code>shift</code> <code>float</code> <p>phase shift angle.</p> required <code>dim</code> <code>int</code> <p>dimension of the circuit matrix.</p> required <code>mode</code> <code>int</code> <p>the mode to which the beam splitter is applied. Starts at 0.</p> required <p>Returns:</p> Name Type Description <code>ndarray</code> <code>NDArray</code> <p>the matrix of the phase shifter.</p> References <p>[1] Clements et al., \"An Optimal Design for Universal Multiport     Interferometers\" arXiv, 2007. https://arxiv.org/pdf/1603.08788.pdf</p> Source code in <code>qoptcraft/optical_elements/optical_elements.py</code> <pre><code>def phase_shifter(shift: float, dim: int, mode: int) -&gt; NDArray:\n\"\"\"Create a phase shifter of a certain angle acting on a mode.\n\n    Args:\n        shift (float): phase shift angle.\n        dim (int): dimension of the circuit matrix.\n        mode (int): the mode to which the beam splitter is applied. Starts at 0.\n\n    Returns:\n        ndarray: the matrix of the phase shifter.\n\n    References:\n        [1] Clements et al., \"An Optimal Design for Universal Multiport\n            Interferometers\" arXiv, 2007. https://arxiv.org/pdf/1603.08788.pdf\n    \"\"\"\n    matrix = np.eye(dim, dtype=np.complex64)\n    matrix[mode, mode] = np.exp(1j * shift)\n    return matrix\n</code></pre>"},{"location":"reference/optical_elements/quasiunitary_decomp/","title":"quasiunitary_decomp","text":""},{"location":"reference/optical_elements/quasiunitary_decomp/#qoptcraft.optical_elements.quasiunitary_decomp","title":"<code>qoptcraft.optical_elements.quasiunitary_decomp</code>","text":"<p>TODO: Implement the quasiunitary decomposition.</p>"},{"location":"reference/optical_elements/quasiunitary_decomp/#qoptcraft.optical_elements.quasiunitary_decomp.quasiunitary_decomp","title":"<code>quasiunitary_decomp()</code>","text":"References <p>N. Tischler, C. Rockstuhl, K. S\u0142owik, Phys. Rev. X 8 (2018) 021017.</p> Source code in <code>qoptcraft/optical_elements/quasiunitary_decomp.py</code> <pre><code>def quasiunitary_decomp():\n\"\"\"\n    References:\n        N. Tischler, C. Rockstuhl, K. S\u0142owik, Phys. Rev. X 8 (2018) 021017.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/optical_elements/reck_decomp/","title":"reck_decomp","text":""},{"location":"reference/optical_elements/reck_decomp/#qoptcraft.optical_elements.reck_decomp","title":"<code>qoptcraft.optical_elements.reck_decomp</code>","text":"<p>Decompose a unitary into beamsplitters following Reck et al.</p>"},{"location":"reference/optical_elements/reck_decomp/#qoptcraft.optical_elements.reck_decomp.reck_decomposition","title":"<code>reck_decomposition(unitary)</code>","text":"<p>Given a unitary matrix calculates the Reck et al. decompositon into beam splitters and phase shifters:</p> <p>D = U \u00b7 BS_1... BS_n  =&gt;  U = D \u00b7 BS_n.inv ... BS_1.inv</p> <p>Parameters:</p> Name Type Description Default <code>unitary</code> <code>NDArray</code> <p>unitary matrix to decompose.</p> required <p>Returns:</p> Type Description <code>tuple[NDArray, list[NDArray]]</code> <p>list[NDArray]: list of matrices that decompose U in the order of the decomposition</p> References <p>[1] Reck et al., \"Experimental realization of any discrete unitary operator\"     Phys. Rev. Lett. 73, 58, 1994. https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.73.58</p> Source code in <code>qoptcraft/optical_elements/reck_decomp.py</code> <pre><code>def reck_decomposition(unitary: NDArray) -&gt; tuple[NDArray, list[NDArray]]:\n\"\"\"Given a unitary matrix calculates the Reck et al. decompositon\n    into beam splitters and phase shifters:\n\n    D = U \u00b7 BS_1... BS_n  =&gt;  U = D \u00b7 BS_n.inv ... BS_1.inv\n\n    Args:\n        unitary (NDArray): unitary matrix to decompose.\n\n    Returns:\n        list[NDArray]: list of matrices that decompose U in the order of the decomposition\n\n    References:\n        [1] Reck et al., \"Experimental realization of any discrete unitary operator\"\n            Phys. Rev. Lett. 73, 58, 1994. https://journals.aps.org/prl/abstract/10.1103/PhysRevLett.73.58\n    \"\"\"\n\n    assert unitary.shape[0] == unitary.shape[1], \"The matrix is not square\"\n    dim = unitary.shape[0]\n\n    bs_list = []\n\n    for row in range(dim - 1, 0, -1):\n        for col in range(row - 1, -1, -1):\n            # Eliminate (row, col) element of U with a beamsplitter T_(row, col)\n\n            # We calculate the beamsplitter angles phi y theta\n            angle, shift = _solve_angles(unitary, row, col)\n            right = beam_splitter(angle, shift, dim, mode_1=row, mode_2=col, convention=\"reck\")\n            unitary = unitary @ right\n            bs_list.append(right.conj().T)\n    diag = unitary\n    bs_list.reverse()\n    return diag, bs_list\n</code></pre>"},{"location":"reference/state/","title":"state","text":""},{"location":"reference/state/#qoptcraft.state","title":"<code>qoptcraft.state</code>","text":""},{"location":"reference/state/_exceptions/","title":"_exceptions","text":""},{"location":"reference/state/_exceptions/#qoptcraft.state._exceptions","title":"<code>qoptcraft.state._exceptions</code>","text":""},{"location":"reference/state/_exceptions/#qoptcraft.state._exceptions.NotHermitianError","title":"<code>NotHermitianError()</code>","text":"<p>         Bases: <code>ValueError</code></p> <p>The matrix is not hermitian.</p> Source code in <code>qoptcraft/state/_exceptions.py</code> <pre><code>def __init__(self) -&gt; None:\n    message = \"The matrix is not hermitian.\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/state/_exceptions/#qoptcraft.state._exceptions.NumberModesError","title":"<code>NumberModesError()</code>","text":"<p>         Bases: <code>ValueError</code></p> <p>Not all states have the same number of modes.</p> Source code in <code>qoptcraft/state/_exceptions.py</code> <pre><code>def __init__(self) -&gt; None:\n    message = \"Not all states have the same number of modes.\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/state/_exceptions/#qoptcraft.state._exceptions.NumberPhotonsError","title":"<code>NumberPhotonsError()</code>","text":"<p>         Bases: <code>ValueError</code></p> <p>Not all states have the same number of photons.</p> Source code in <code>qoptcraft/state/_exceptions.py</code> <pre><code>def __init__(self) -&gt; None:\n    message = \"Not all states have the same number of photons.\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/state/_exceptions/#qoptcraft.state._exceptions.ProbabilityError","title":"<code>ProbabilityError(sum_probs)</code>","text":"<p>         Bases: <code>ValueError</code></p> <p>Probabilities don't add up to 1.</p> Source code in <code>qoptcraft/state/_exceptions.py</code> <pre><code>def __init__(self, sum_probs: float) -&gt; None:\n    message = f\"The sum of the probabilities is {sum_probs} instead of 1.\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/state/_exceptions/#qoptcraft.state._exceptions.PureStateLengthError","title":"<code>PureStateLengthError()</code>","text":"<p>         Bases: <code>ValueError</code></p> <p>States and probabilities differ in length.</p> Source code in <code>qoptcraft/state/_exceptions.py</code> <pre><code>def __init__(self) -&gt; None:\n    message = \"States and probabilities differ in length.\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/state/state/","title":"state","text":""},{"location":"reference/state/state/#qoptcraft.state.state","title":"<code>qoptcraft.state.state</code>","text":"<p>Implement a class to describe a pure state photonic state.</p>"},{"location":"reference/state/state/#qoptcraft.state.state.Fock","title":"<code>Fock(*photons, coef=1)</code>","text":"<p>         Bases: <code>PureState</code></p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __init__(self, *photons: int, coef: Number = 1) -&gt; None:\n    super().__init__(fock_states=(photons,), coefs=(coef,))\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.Fock.__iter__","title":"<code>__iter__()</code>","text":"<p>Iterate the photons of the Fock state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __iter__(self):\n\"\"\"Iterate the photons of the Fock state.\"\"\"\n    yield from self.fock_states[0]\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.Fock.__len__","title":"<code>__len__()</code>","text":"<p>Number of modes in the fock state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __len__(self):\n\"\"\"Number of modes in the fock state.\"\"\"\n    return self.modes\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.MixedState","title":"<code>MixedState(density_matrix, modes, photons)</code>","text":"<p>         Bases: <code>State</code></p> <p>A mixed quantum state.</p> <p>Parameters:</p> Name Type Description Default <code>density_matrix</code> <code>NDArray</code> <p>provide directly the density matrix of the mixed state.</p> required <code>modes</code> <code>int</code> <p>number of modes in the optical network.</p> required <code>photons</code> <code>int</code> <p>number of photons.</p> required <p>Attributes:</p> Name Type Description <code>density_matrix</code> <code>NDArray</code> <p>density matrix of the state.</p> <code>modes</code> <code>int</code> <p>number of modes in the optical network.</p> <code>photons</code> <code>int</code> <p>number of photons.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __init__(\n    self,\n    density_matrix: NDArray | scipy.sparse.spmatrix,\n    modes: int,\n    photons: int,\n) -&gt; None:\n    def is_hermitian(density_matrix, rtol: float = 1e-5, atol: float = 1e-8):\n\"\"\"Reimplement numpy isclose for spare matrices\"\"\"\n        mat_1 = density_matrix\n        mat_2 = density_matrix.conj().T\n        return abs(mat_1 - mat_2).max() &lt;= atol + rtol * abs(mat_2).max()\n\n    if not is_hermitian(density_matrix):\n        raise NotHermitianError()\n    if not np.isclose(density_matrix.trace(), 1):\n        raise ValueError(\"Density matrix trace is not 1.\")\n    self.density_matrix = density_matrix\n    self.photons = photons\n    self.modes = modes\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.MixedState.from_mixture","title":"<code>from_mixture(pure_states, probs)</code>  <code>classmethod</code>","text":"<p>Initialize a mixed state from a superposition of pure states instead of initializing directly the density matrix.</p> <p>Parameters:</p> Name Type Description Default <code>pure_states</code> <code>list[PureState]</code> <p>pure states in the statistical mixture.</p> required <code>probs</code> <code>ArrayLike</code> <p>probability of measuring each pure state.</p> required <p>Raises:</p> Type Description <code>PureStateLengthError</code> <p>States and probabilities differ in length.</p> <code>ProbabilityError</code> <p>Probabilities don't add up to 1.</p> <code>NumberPhotonsError</code> <p>Not all states have the same number of photons.</p> <code>NumberModesError</code> <p>Not all states have the same number of modes.</p> <p>Returns:</p> Type Description <code>Self</code> <p>MixedState</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>@classmethod\ndef from_mixture(cls, pure_states: list[PureState], probs: ArrayLike) -&gt; Self:\n\"\"\"Initialize a mixed state from a superposition of pure states instead of\n    initializing directly the density matrix.\n\n    Args:\n        pure_states (list[PureState]): pure states in the statistical mixture.\n        probs (ArrayLike): probability of measuring each pure state.\n\n    Raises:\n        PureStateLengthError: States and probabilities differ in length.\n        ProbabilityError: Probabilities don't add up to 1.\n        NumberPhotonsError: Not all states have the same number of photons.\n        NumberModesError: Not all states have the same number of modes.\n\n    Returns:\n        MixedState\n    \"\"\"\n    if not len(pure_states) == len(probs):\n        raise PureStateLengthError()\n    if not np.isclose(1, sum(probs)):\n        raise ProbabilityError(sum(probs))\n\n    photons_list = [state.photons for state in pure_states]\n    if not all(photons == photons_list[0] for photons in photons_list):\n        raise NumberPhotonsError()\n\n    modes_list = [state.modes for state in pure_states]\n    if not all(modes == modes_list[0] for modes in modes_list):\n        raise NumberModesError()\n\n    density_matrix = probs[0] * pure_states[0].density_matrix\n    for i in range(1, len(probs)):\n        density_matrix += probs[i] * pure_states[i].density_matrix\n\n    return cls(density_matrix, modes_list[0], photons_list[0])\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState","title":"<code>PureState(fock_states, coefs)</code>","text":"<p>         Bases: <code>State</code></p> <p>A pure quantum state.</p> <p>Parameters:</p> Name Type Description Default <code>fock_states</code> <code>tuple[tuple[int, ...]]</code> <p>Fock states that, in superposition, constitute our pure state.</p> required <code>coefs</code> <code>ArrayLike</code> <p>amplitude of each Fock state in the superposition.</p> required <p>Attributes:</p> Name Type Description <code>modes</code> <code>int</code> <p>number of modes in the optical network.</p> <code>photons</code> <code>int</code> <p>number of photons.</p> <code>basis</code> <code>tuple[tuple[int, ...]]</code> <p>basis of the Hilbert state. Defaults to None.</p> <code>density_matrix</code> <code>NDArray</code> <p>density matrix of the state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __init__(self, fock_states: list[tuple[int, ...]], coefs: ArrayLike) -&gt; None:\n    self._assert_inputs(fock_states, coefs)\n\n    self.photons: int = sum(fock_states[0])\n    self.modes: int = len(fock_states[0])\n\n    sorted_inputs = sorted(\n        zip(fock_states, coefs, strict=True), key=lambda pair: pair[0], reverse=True\n    )\n    # sorted_inputs = [pair for pair in sorted_inputs if not np.isclose(pair[1], 0)]\n    self.fock_states, coefs = zip(*sorted_inputs, strict=True)\n    self.coefs = np.array(coefs)\n\n    sum_coefs = np.sum(np.abs(self.coefs) ** 2)\n    if sum_coefs == 0:\n        self.amplitudes = self.coefs\n    else:\n        self.amplitudes = np.array(coefs) / np.sqrt(sum_coefs)\n    self.probabilites: NDArray = np.abs(self.amplitudes) ** 2\n\n    self.basis: tuple[tuple[int, ...]] | None = None\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.density_matrix","title":"<code>density_matrix</code>  <code>property</code>","text":"<p>Density matrix of the pure state in a certain basis.</p>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__add__","title":"<code>__add__(other)</code>","text":"<p>Tensor product of self with other state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __add__(self, other: PureState) -&gt; Self:\n\"\"\"Tensor product of self with other state.\"\"\"\n    if other == 0:\n        return self\n    if isinstance(other, PureState):\n        if self.photons != other.photons:\n            raise NumberPhotonsError()\n        if self.modes != other.modes:\n            raise NumberModesError()\n\n        coefs = []\n        fock_states = list(set(self.fock_states) | set(other.fock_states))\n        for fock in fock_states:\n            try:\n                coefs.append(self._coef_fock(fock))\n                try:\n                    coefs[-1] += other._coef_fock(fock)\n                except ValueError:\n                    continue\n            except ValueError:\n                coefs.append(other._coef_fock(fock))\n        return PureState(fock_states, coefs)\n\n    logging.error(f\"Addition not implemented for opperand type {type(other)}\")\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare if two pure states are equal.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __eq__(self, other: PureState) -&gt; bool:\n\"\"\"Compare if two pure states are equal.\"\"\"\n    if isinstance(other, PureState):\n        if self.photons != other.photons or self.modes != other.modes:\n            return False\n        if self.fock_states != other.fock_states:\n            fock_diff = set(self.fock_states).symmetric_difference(other.fock_states)\n            print(f\"Unequal fock states. Difference in fock states = {fock_diff}.\")\n            return False\n        if not np.allclose(self.amplitudes, other.amplitudes):\n            print(\"Amplitudes differ\")\n            return False\n        return True\n    return False\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__iadd__","title":"<code>__iadd__(other)</code>","text":"<p>Inplace addition of states.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __iadd__(self, other: PureState) -&gt; Self:\n\"\"\"Inplace addition of states.\"\"\"\n    return self + other\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__imul__","title":"<code>__imul__(other)</code>","text":"<p>Tensor product of self with other state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __imul__(self, other: PureState | Number) -&gt; Self:\n\"\"\"Tensor product of self with other state.\"\"\"\n    return self * other\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__isub__","title":"<code>__isub__(other)</code>","text":"<p>Inplace substraction of states.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __isub__(self, other: PureState) -&gt; Self:\n\"\"\"Inplace substraction of states.\"\"\"\n    return self - other\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__mul__","title":"<code>__mul__(other)</code>","text":"<p>Tensor product of self with other state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __mul__(self, other: PureState | Number) -&gt; Self:\n\"\"\"Tensor product of self with other state.\"\"\"\n    if isinstance(other, Number):\n        return PureState(self.fock_states, self.coefs * other)\n    if isinstance(other, PureState):\n        fock_states = []\n        amplitudes = []\n        for fock, amp in zip(self.fock_states, self.amplitudes, strict=True):\n            for fock_other, amp_other in zip(other.fock_states, other.amplitudes, strict=True):\n                fock_states.append(fock + fock_other)\n                amplitudes.append(amp * amp_other)\n        return PureState(fock_states, amplitudes)\n    else:\n        logging.error(f\"Operation not implemented for opperand type {type(other)}\")\n        raise NotImplementedError\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__pow__","title":"<code>__pow__(exponent, modulo=None)</code>","text":"<p>Tensor product of self with itself a given number of times.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __pow__(self, exponent: int, modulo=None) -&gt; Self:\n\"\"\"Tensor product of self with itself a given number of times.\"\"\"\n    state = self\n    for _ in range(exponent - 1):\n        state = state * self\n    return state\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__radd__","title":"<code>__radd__(other)</code>","text":"<p>Tensor product of self with other state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __radd__(self, other: PureState) -&gt; Self:\n\"\"\"Tensor product of self with other state.\"\"\"\n    return self + other\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__repr__","title":"<code>__repr__()</code>","text":"<p>Representation of the state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __repr__(self) -&gt; str:\n\"\"\"Representation of the state.\"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__rmul__","title":"<code>__rmul__(other)</code>","text":"<p>Tensor product of self with other state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __rmul__(self, other: PureState | Number) -&gt; Self:\n\"\"\"Tensor product of self with other state.\"\"\"\n    return self * other\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __str__(self) -&gt; str:\n\"\"\"String representation of the state.\"\"\"\n    str_ = \"\"\n    for fock, amp in zip(self.fock_states, self.amplitudes, strict=True):\n        str_ = str_ + f\"{amp:.2f} * {fock} + \\n\"\n    str_ = str_[:-4]\n    return str_\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__sub__","title":"<code>__sub__(other)</code>","text":"<p>Substraction of states.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __sub__(self, other: PureState) -&gt; Self:\n\"\"\"Substraction of states.\"\"\"\n    if isinstance(other, PureState):\n        if self.photons != other.photons:\n            raise NumberPhotonsError()\n        if self.modes != other.modes:\n            raise NumberModesError()\n        return self + (-1) * other\n    logging.error(f\"Substraction not implemented for opperand type {type(other)}\")\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.__truediv__","title":"<code>__truediv__(other)</code>","text":"<p>Return the division of self and the other number.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Number</code> <p>Other scalar value (rhs).</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Division by zero.</p> <code>TypeError</code> <p>Not int/float passed in.</p> <p>Returns:</p> Type Description <code>Self</code> <p>The multiplication of self and the other vector/number.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def __truediv__(self, other: Number) -&gt; Self:\n\"\"\"Return the division of self and the other number.\n\n    Args:\n        other: Other scalar value (rhs).\n\n    Raises:\n        ValueError: Division by zero.\n        TypeError: Not int/float passed in.\n\n    Returns:\n        The multiplication of self and the other vector/number.\n    \"\"\"\n    if not isinstance(other, Number):\n        raise TypeError(\"You must pass in a scalar value.\")\n    return self * (1 / other)\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.amp_fock","title":"<code>amp_fock(fock)</code>","text":"<p>Get the amplitude of a certain fock state in the basis.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def amp_fock(self, fock: tuple[int, ...]) -&gt; Number:\n\"\"\"Get the amplitude of a certain fock state in the basis.\"\"\"\n    index = self.fock_states.index(fock)\n    return self.amplitudes[index]\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.annihilation","title":"<code>annihilation(mode)</code>","text":"<p>Annihilation of a photon in a certain mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>mode in which to annihilate.</p> required <p>Returns:</p> Name Type Description <code>PureState</code> <code>Self</code> <p>created state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def annihilation(self, mode: int) -&gt; Self:\n\"\"\"Annihilation of a photon in a certain mode.\n\n    Args:\n        mode (int): mode in which to annihilate.\n\n    Returns:\n        PureState: created state.\n    \"\"\"\n    state = 0\n    for fock, coef in zip(self.fock_states, self.coefs, strict=True):\n        fock_annih, coef_annih = annihilation(mode, fock)\n        if coef_annih == 0:\n            continue\n        state += Fock(*fock_annih, coef=coef_annih * coef)\n    return state\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.coefs_in_basis","title":"<code>coefs_in_basis()</code>","text":"<p>Provide the coefs of the state in the fock basis.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def coefs_in_basis(self) -&gt; NDArray:\n\"\"\"Provide the coefs of the state in the fock basis.\"\"\"\n    if self.basis is None:\n        self.basis = get_photon_basis(self.modes, self.photons)\n\n    state = np.zeros(len(self.basis), dtype=complex)\n\n    for i, fock in enumerate(self.fock_states):\n        for j, basis_fock in enumerate(self.basis):\n            if fock == basis_fock:\n                state[j] = self.coefs[i]\n    return state\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.creation","title":"<code>creation(mode)</code>","text":"<p>Creation of a photon in a certain mode.</p> <p>Parameters:</p> Name Type Description Default <code>mode</code> <code>int</code> <p>mode in which to create.</p> required <p>Returns:</p> Name Type Description <code>PureState</code> <code>PureState</code> <p>created state.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def creation(self, mode: int) -&gt; PureState:\n\"\"\"Creation of a photon in a certain mode.\n\n    Args:\n        mode (int): mode in which to create.\n\n    Returns:\n        PureState: created state.\n    \"\"\"\n    state = 0\n    for fock, coef in zip(self.fock_states, self.coefs, strict=True):\n        fock_created, coef_creat = creation(mode, fock)\n        state += Fock(*fock_created, coef=coef_creat * coef)\n    return state\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.exp_photons","title":"<code>exp_photons(mode_creat, mode_annih)</code>","text":"<p>Compute the expecation value of $a^\\dagger_i a_j$.</p> <p>Parameters:</p> Name Type Description Default <code>mode_creat</code> <code>int</code> <p>mode where we apply the creation operator.</p> required <code>mode_annih</code> <code>int</code> <p>mode where we apply the annihilation operator.</p> required <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>expectation value.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def exp_photons(self, mode_creat: int, mode_annih: int) -&gt; float:\nr\"\"\"Compute the expecation value of $a^\\dagger_i a_j$.\n\n    Args:\n        mode_creat (int): mode where we apply the creation operator.\n        mode_annih (int): mode where we apply the annihilation operator.\n\n    Returns:\n        float: expectation value.\n    \"\"\"\n    exp = 0\n    if mode_creat == mode_annih:\n        for i, fock in enumerate(self.fock_states):\n            exp += self.probabilites[i] * fock[mode_creat]\n    else:\n        for i, fock in enumerate(self.fock_states):\n            fock_, coef_ = annihilation(mode_annih, fock)\n            # if coef_ == 0:  # not really necessary to check this\n            ##### continue  # since it will raise a ValueError below\n            coef = self.amplitudes[i] * coef_\n            fock_, coef_ = creation(mode_creat, fock_)\n            coef *= coef_\n            try:\n                exp += coef * self.amp_fock(fock_).conjugate()\n            except ValueError:\n                continue\n    return exp\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.isclose","title":"<code>isclose(other, atol=0.001, rtol=1e-05)</code>","text":"<p>Compare if two pure states are equal.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def isclose(self, other: PureState, atol: float = 1e-3, rtol=1e-05) -&gt; bool:\n\"\"\"Compare if two pure states are equal.\"\"\"\n    if isinstance(other, PureState):\n        if self.photons != other.photons or self.modes != other.modes:\n            return False\n        fock_states = list(set(self.fock_states) | set(other.fock_states))\n        for fock in fock_states:\n            try:\n                coef_self = np.abs(self._coef_fock(fock))\n                try:\n                    coef_other = np.abs(other._coef_fock(fock))\n                    if not np.isclose(coef_self, coef_other, atol=atol, rtol=rtol):\n                        print(f\"{fock = }, {coef_self = }, {coef_other = }\")\n                        return False\n                except ValueError:\n                    if not np.isclose(coef_self, 0, atol=atol, rtol=rtol):\n                        print(f\"{fock = }, {coef_self = }, coef_other = 0\")\n                        return False\n            except ValueError:\n                coef_other = np.abs(other._coef_fock(fock))\n                if not np.isclose(coef_other, 0, atol=atol, rtol=rtol):\n                    print(f\"{fock = }, coef_self = 0, {coef_other = }\")\n                    return False\n        return True\n    raise ValueError(\"other is not PureState\")\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.PureState.state_in_basis","title":"<code>state_in_basis()</code>","text":"<p>Output the state vector in the Fock basis.</p> Source code in <code>qoptcraft/state/state.py</code> <pre><code>def state_in_basis(self) -&gt; NDArray:\n\"\"\"Output the state vector in the Fock basis.\"\"\"\n    if self.basis is None:\n        self.basis = get_photon_basis(self.modes, self.photons)\n\n    state = np.zeros(len(self.basis), dtype=complex)\n\n    for i, fock in enumerate(self.fock_states):\n        for j, basis_fock in enumerate(self.basis):\n            if fock == basis_fock:\n                state[j] = self.amplitudes[i]\n    return state\n</code></pre>"},{"location":"reference/state/state/#qoptcraft.state.state.State","title":"<code>State</code>","text":"<p>Base type for our quantum states.</p>"},{"location":"reference/toponogov/","title":"toponogov","text":""},{"location":"reference/toponogov/#qoptcraft.toponogov","title":"<code>qoptcraft.toponogov</code>","text":""},{"location":"reference/toponogov/toponogov/","title":"toponogov","text":""},{"location":"reference/toponogov/toponogov/#qoptcraft.toponogov.toponogov","title":"<code>qoptcraft.toponogov.toponogov</code>","text":"<p>Use Topogonov's theorem to get a scattering matrix that approximates a given unitary.</p>"},{"location":"reference/toponogov/toponogov/#qoptcraft.toponogov.toponogov.toponogov","title":"<code>toponogov(matrix, modes, photons, seed=None)</code>","text":"<p>Use Topogonov's theorem to approximate a given unitary using linear optics.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>NDArray</code> <p>unitary matrix to approximate.</p> required <code>modes</code> <code>int</code> <p>number of modes.</p> required <code>photons</code> <code>int</code> <p>number of photons.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Matrix dimension doesn't match the number of modes and photons.</p> <p>Returns:</p> Type Description <code>tuple[NDArray, float]</code> <p>NDArray, float: approximated unitary and the error.</p> Source code in <code>qoptcraft/toponogov/toponogov.py</code> <pre><code>def toponogov(matrix: NDArray, modes: int, photons: int, seed: int = None) -&gt; tuple[NDArray, float]:\n\"\"\"Use Topogonov's theorem to approximate a given unitary using linear optics.\n\n    Args:\n        matrix (NDArray): unitary matrix to approximate.\n        modes (int): number of modes.\n        photons (int): number of photons.\n\n    Raises:\n        ValueError: Matrix dimension doesn't match the number of modes and photons.\n\n    Returns:\n        NDArray, float: approximated unitary and the error.\n    \"\"\"\n    dim = len(matrix)\n    if dim != hilbert_dim(modes, photons):\n        raise ValueError(f\"Matrix {dim = } doesn't match with {photons = } and {modes = }.\")\n\n    basis, basis_image = get_algebra_basis(modes, photons)\n    basis_image = gram_schmidt(basis_image)\n\n    scattering_init = haar_random_unitary(modes, seed=seed)\n    unitary = photon_unitary(scattering_init, photons, \"hamiltonian\")  # initial guess\n\n    error: float = hs_norm(matrix - unitary)\n    error_prev: float = 0\n\n    while np.abs(error - error_prev) &gt; 1e-8:\n        unitary_inv = np.linalg.inv(unitary)\n        log = log_matrix(unitary_inv @ matrix, method=\"schur\")\n        log_projected = np.zeros_like(unitary)  # Initialize to 0\n        for basis_matrix in basis_image:\n            coef = hs_scalar_product(log, basis_matrix)\n            log_projected += coef * basis_matrix\n\n        unitary = unitary.dot(expm(log_projected))\n\n        error_prev = error\n        error = hs_norm(matrix - unitary)\n    return unitary, error\n</code></pre>"},{"location":"scripts/copy_examples/","title":"Copy examples","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Script to copy the examples folder into the docs.\n\"\"\"\n</pre> \"\"\"Script to copy the examples folder into the docs. \"\"\" In\u00a0[\u00a0]: Copied! <pre>import shutil\nfrom pathlib import Path\n</pre> import shutil from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>docs_path = Path(\"docs\", \"examples\")\n</pre> docs_path = Path(\"docs\", \"examples\") In\u00a0[\u00a0]: Copied! <pre>for notebook in Path(\"examples\").glob(\"*.ipynb\"):\n    shutil.copy(notebook, docs_path)\n</pre> for notebook in Path(\"examples\").glob(\"*.ipynb\"):     shutil.copy(notebook, docs_path)"},{"location":"scripts/gen_ref_nav/","title":"Gen ref nav","text":"In\u00a0[\u00a0]: Copied! <pre>\"\"\"Script to generate the documentation pages and navigation for our library.\n\nImportant: remember to change PATH_LIBRARY to whatever name your package\nfolder has!!\n\"\"\"\n</pre> \"\"\"Script to generate the documentation pages and navigation for our library.  Important: remember to change PATH_LIBRARY to whatever name your package folder has!! \"\"\" In\u00a0[\u00a0]: Copied! <pre>import sys\nimport os\nfrom pathlib import Path\n</pre> import sys import os from pathlib import Path In\u00a0[\u00a0]: Copied! <pre>import mkdocs_gen_files\n</pre> import mkdocs_gen_files In\u00a0[\u00a0]: Copied! <pre>nav = mkdocs_gen_files.Nav()\nPATH_LIBRARY = \"qoptcraft\"  # change this with your library's name\n</pre> nav = mkdocs_gen_files.Nav() PATH_LIBRARY = \"qoptcraft\"  # change this with your library's name In\u00a0[\u00a0]: Copied! <pre>if os.path.isdir(PATH_LIBRARY) is False:\n    sys.exit(\n        \"Package folder was not found. Please change the PATH_LIBRARY\"\n        \" variable in the docs/scripts/gen_ref_nav.py script.\"\n    )\n</pre> if os.path.isdir(PATH_LIBRARY) is False:     sys.exit(         \"Package folder was not found. Please change the PATH_LIBRARY\"         \" variable in the docs/scripts/gen_ref_nav.py script.\"     ) In\u00a0[\u00a0]: Copied! <pre>for path in sorted(Path(PATH_LIBRARY).rglob(\"*.py\")):\n    module_path = path.relative_to(\"\").with_suffix(\"\")\n    doc_path = path.relative_to(PATH_LIBRARY).with_suffix(\".md\")\n    full_doc_path = Path(\"reference\", doc_path)\n\n    parts = tuple(module_path.parts)\n\n    if parts[-1] == \"__init__\":\n        parts = parts[:-1]\n        doc_path = doc_path.with_name(\"index.md\")\n        full_doc_path = full_doc_path.with_name(\"index.md\")\n    elif parts[-1] == \"__main__\":\n        continue\n\n    if \"_legacy\" in parts:\n        continue\n\n    nav[parts] = doc_path.as_posix()\n\n    with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:\n        ident = \".\".join(parts)\n        fd.write(f\"::: {ident}\\n\")\n        fd.write(\"\\thandler: python\\n\")\n        fd.write(\"\\toptions:\\n\")\n        fd.write(\"\\t\\tshow_root_heading: true\\n\")\n        fd.write(\"\\t\\tshow_source: true\\n\")\n\n    mkdocs_gen_files.set_edit_path(full_doc_path, path)\n</pre> for path in sorted(Path(PATH_LIBRARY).rglob(\"*.py\")):     module_path = path.relative_to(\"\").with_suffix(\"\")     doc_path = path.relative_to(PATH_LIBRARY).with_suffix(\".md\")     full_doc_path = Path(\"reference\", doc_path)      parts = tuple(module_path.parts)      if parts[-1] == \"__init__\":         parts = parts[:-1]         doc_path = doc_path.with_name(\"index.md\")         full_doc_path = full_doc_path.with_name(\"index.md\")     elif parts[-1] == \"__main__\":         continue      if \"_legacy\" in parts:         continue      nav[parts] = doc_path.as_posix()      with mkdocs_gen_files.open(full_doc_path, \"w\") as fd:         ident = \".\".join(parts)         fd.write(f\"::: {ident}\\n\")         fd.write(\"\\thandler: python\\n\")         fd.write(\"\\toptions:\\n\")         fd.write(\"\\t\\tshow_root_heading: true\\n\")         fd.write(\"\\t\\tshow_source: true\\n\")      mkdocs_gen_files.set_edit_path(full_doc_path, path) In\u00a0[\u00a0]: Copied! <pre>with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:\n    nav_file.writelines(nav.build_literate_nav())\n</pre> with mkdocs_gen_files.open(\"reference/SUMMARY.txt\", \"w\") as nav_file:     nav_file.writelines(nav.build_literate_nav())"}]}